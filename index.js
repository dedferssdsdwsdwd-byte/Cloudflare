import { connect } from 'cloudflare:sockets'; const Config = { userID: 'd342d11e-d424-4583-b36e-524ab1f0afa4', proxyIPs: ['nima.nscl.ir:443', 'bpb.yousef.isegaro.com:443'], scamalytics: { username: 'victoriacrossn', apiKey: 'ed89b4fef21aba43c15cdd15cff2138dd8d3bbde5aaaa4690ad8e94990448516', baseUrl: 'https://api12.scamalytics.com/v3/', }, socks5: { enabled: false, relayMode: false, address: '', }, async fromEnv(env) { let selectedProxyIP = null; if (env.DB) { try { const { results } = await env.DB.prepare( "SELECT ip_port FROM proxy_health WHERE is_healthy = 1 ORDER BY latency_ms ASC LIMIT 1" ).all(); selectedProxyIP = results[0]?.ip_port || null; } catch (e) { console.error(e.message); } } if (!selectedProxyIP) { selectedProxyIP = env.PROXYIP; } if (!selectedProxyIP) { selectedProxyIP = this.proxyIPs[Math.floor(Math.random() * this.proxyIPs.length)]; } if (!selectedProxyIP) { console.error('CRITICAL ERROR: No VLESS proxy IP available. Service will be severely degraded.'); selectedProxyIP = this.proxyIPs[0] || '127.0.0.1:443'; } const [proxyHost, proxyPort = '443'] = selectedProxyIP.split(':'); const socks5Address = env.SOCKS5 || this.socks5.address; let socks5Enabled = !!env.SOCKS5 || this.socks5.enabled; let parsedSocks5Address = null; if (socks5Enabled && socks5Address) { try { parsedSocks5Address = socks5AddressParser(socks5Address); } catch (e) { console.error(e.message); socks5Enabled = false; } } return { userID: env.UUID || this.userID, proxyIP: proxyHost, proxyPort: parseInt(proxyPort, 10), proxyAddress: selectedProxyIP, scamalytics: { username: env.SCAMALYTICS_USERNAME || this.scamalytics.username, apiKey: env.SCAMALYTICS_API_KEY || this.scamalytics.apiKey, baseUrl: env.SCAMALYTICS_BASEURL || this.scamalytics.baseUrl, }, socks5: { enabled: socks5Enabled, relayMode: env.SOCKS5_RELAY === 'true' || this.socks5.relayMode, address: socks5Address, }, parsedSocks5Address: parsedSocks5Address, }; }, }; const CONST = { ED_PARAMS: { ed: 2560, eh: 'Sec-WebSocket-Protocol' }, VLESS_PROTOCOL: 'vless', WS_READY_STATE_OPEN: 1, WS_READY_STATE_CLOSING: 2, ADMIN_LOGIN_FAIL_LIMIT: 5, ADMIN_LOGIN_LOCK_TTL: 600, ADMIN_SESSION_TTL: 86400, SCAMALYTICS_THRESHOLD: 50, USER_PATH_RATE_LIMIT: 20, USER_PATH_RATE_TTL: 60, IP_BLACKLIST_TTL: 3600, BRUTE_FORCE_LOGIN_ATTEMPTS: 10, BRUTE_FORCE_LOGIN_TTL: 300, INVALID_UUID_ATTEMPTS: 50, INVALID_UUID_TTL: 60, PORT_SCAN_THRESHOLD: 10, PORT_SCAN_TTL: 30, ADMIN_AUTO_REFRESH_INTERVAL: 60000, IP_CLEANUP_AGE_DAYS: 30, HEALTH_CHECK_INTERVAL: 300000, HEALTH_CHECK_TIMEOUT: 5000, DB_CACHE_TTL: 3600, }; function generateNonce() { const arr = new Uint8Array(16); crypto.getRandomValues(arr); return btoa(String.fromCharCode.apply(null, arr)); } function addSecurityHeaders(headers, nonce, cspDomains = {}) { const scriptSrc = nonce ? `script-src 'self' 'nonce-${nonce}' 'unsafe-inline' https://cdnjs.cloudflare.com https://unpkg.com https://chart.googleapis.com` : "script-src 'self' https://cdnjs.cloudflare.com https://unpkg.com https://chart.googleapis.com 'unsafe-inline'"; const styleSrc = "style-src 'self' 'unsafe-inline' 'unsafe-hashes'"; const csp = [ "default-src 'self'", "form-action 'self'", "object-src 'none'", "frame-ancestors 'none'", "base-uri 'self'", scriptSrc, styleSrc, `img-src 'self' data: blob: https: ${cspDomains.img || ''}`.trim(), `connect-src 'self' https: wss: ${cspDomains.connect || ''}`.trim(), "worker-src 'self' blob:", "child-src 'self' blob:", "frame-src 'none'", "font-src 'self' https: data:", ]; headers.set('Content-Security-Policy', csp.join('; ')); headers.set('Strict-Transport-Security', 'max-age=63072000; includeSubDomains; preload'); headers.set('X-Content-Type-Options', 'nosniff'); headers.set('X-Frame-Options', 'SAMEORIGIN'); headers.set('Referrer-Policy', 'strict-origin-when-cross-origin'); headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=(), payment=(), usb=()'); headers.set('alt-svc', 'h3=":443"; ma=0'); headers.set('Cross-Origin-Opener-Policy', 'same-origin'); headers.set('Cross-Origin-Embedder-Policy', 'unsafe-none'); headers.set('Cross-Origin-Resource-Policy', 'cross-origin'); headers.set('X-XSS-Protection', '1; mode=block'); } function timingSafeEqual(a, b) { if (typeof a !== 'string' || typeof b !== 'string') return false; const aLen = a.length; const bLen = b.length; let result = 0; if (aLen !== bLen) { for (let i = 0; i < aLen; i++) { result |= a.charCodeAt(i) ^ a.charCodeAt(i); } return false; } for (let i = 0; i < aLen; i++) { result |= a.charCodeAt(i) ^ b.charCodeAt(i); } return result === 0; } function escapeHTML(str) { if (typeof str !== 'string') return ''; const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', }; return str.replace(/[&<>"']/g, m => map[m]); } function safeBase64Encode(str) { try { const encoder = new TextEncoder(); const bytes = encoder.encode(str); let binary = ''; for (let i = 0; i < bytes.length; i++) { binary += String.fromCharCode(bytes[i]); } return btoa(binary); } catch (e) { console.warn(e); return btoa(unescape(encodeURIComponent(str))); } } function generateUUID() { return crypto.randomUUID(); } function isValidUUID(uuid) { if (typeof uuid !== 'string') return false; const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i; return uuidRegex.test(uuid); } function isExpired(expDate, expTime) { if (!expDate || !expTime) return true; const cleanTime = expTime.includes(':') && expTime.split(':').length === 2 ? `${expTime}:00` : expTime.split('.')[0]; const expDatetimeUTC = new Date(`${expDate}T${cleanTime}Z`); return isNaN(expDatetimeUTC.getTime()) || expDatetimeUTC <= new Date(); } async function formatBytes(bytes) { if (bytes === 0 || bytes === null || bytes === undefined) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i))).toFixed(2) + ' ' + sizes[i]; } function base32ToBuffer(base32) { const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; const str = base32.toUpperCase().replace(/=+$/, ''); let bits = 0; let value = 0; let index = 0; const output = new Uint8Array(Math.floor(str.length * 5 / 8)); for (let i = 0; i < str.length; i++) { const char = str[i]; const charValue = base32Chars.indexOf(char); if (charValue === -1) throw new Error('Invalid Base32 character'); value = (value << 5) | charValue; bits += 5; if (bits >= 8) { output[index++] = (value >>> (bits - 8)) & 0xFF; bits -= 8; } } return output.buffer.slice(0, index); } async function generateHOTP(secretBuffer, counter) { const counterBuffer = new ArrayBuffer(8); new DataView(counterBuffer).setBigUint64(0, BigInt(counter), false); const key = await crypto.subtle.importKey( 'raw', secretBuffer, { name: 'HMAC', hash: 'SHA-1' }, false, ['sign'] ); const hmac = await crypto.subtle.sign('HMAC', key, counterBuffer); const hmacBuffer = new Uint8Array(hmac); const offset = hmacBuffer[hmacBuffer.length - 1] & 0x0F; const binary = ( ((hmacBuffer[offset] & 0x7F) << 24) | ((hmacBuffer[offset + 1] & 0xFF) << 16) | ((hmacBuffer[offset + 2] & 0xFF) << 8) | (hmacBuffer[offset + 3] & 0xFF) ); const otp = binary % 1000000; return otp.toString().padStart(6, '0'); } async function validateTOTP(secret, code) { if (!secret || !code || code.length !== 6 || !/^\d{6}$/.test(code)) { return false; } let secretBuffer; try { secretBuffer = base32ToBuffer(secret); } catch (e) { console.error(e.message); return false; } const timeStep = 30; const epoch = Math.floor(Date.now() / 1000); const currentCounter = Math.floor(epoch / timeStep); const counters = [currentCounter, currentCounter - 1, currentCounter + 1]; for (const counter of counters) { const generatedCode = await generateHOTP(secretBuffer, counter); if (timingSafeEqual(code, generatedCode)) { return true; } } return false; } async function hashSHA256(str) { const encoder = new TextEncoder(); const data = encoder.encode(str); const hashBuffer = await crypto.subtle.digest('SHA-256', data); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); } async function d1KvGet(db, key, type = 'text') { if (!db) { return null; } try { const stmt = db.prepare("SELECT value, expiration FROM key_value WHERE key = ?").bind(key); const res = await stmt.first(); if (!res) return null; if (res.expiration && res.expiration < Math.floor(Date.now() / 1000)) { db.prepare("DELETE FROM key_value WHERE key = ?").bind(key).run().catch(e => console.error(e.message)); return null; } if (type === 'json') { try { return JSON.parse(res.value); } catch (e) { console.error(e.message); return null; } } return res.value; } catch (e) { console.error(e.message, e.stack); return null; } } async function d1KvPut(db, key, value, options = {}) { if (!db) { return; } try { let serializedValue = value; if (typeof value === 'object' && value !== null) { serializedValue = JSON.stringify(value); } const expiration = options.expirationTtl ? Math.floor(Date.now() / 1000 + options.expirationTtl) : null; await db.prepare( "INSERT OR REPLACE INTO key_value (key, value, expiration) VALUES (?, ?, ?)" ).bind(key, serializedValue, expiration).run(); } catch (e) { console.error(e.message); } } async function d1KvDelete(db, key) { if (!db) { return; } try { await db.prepare("DELETE FROM key_value WHERE key = ?").bind(key).run(); } catch (e) { console.error(e.message); } } async function checkRateLimit(db, key, limit, ttl) { if (!db) { return false; } try { const countStr = await d1KvGet(db, key); const count = parseInt(countStr, 10) || 0; if (count >= limit) { return true; } await d1KvPut(db, key, (count + 1).toString(), { expirationTtl: ttl }); return false; } catch (e) { console.error(e.message); return false; } } async function logSecurityEvent(db, ctx, ip, type, details, uuid = null) { if (!db) { return; } try { const timestamp = Math.floor(Date.now() / 1000); const stmt = db.prepare( "INSERT INTO security_events (timestamp, ip, type, details, uuid) VALUES (?, ?, ?, ?, ?)" ).bind(timestamp, ip, type, details, uuid); ctx.waitUntil(stmt.run().catch(e => console.error(e.message))); } catch (e) { console.error(e.message, e.stack); } } async function addIpToBlacklist(db, ctx, ip, reason, ttl = CONST.IP_BLACKLIST_TTL) { if (!db) { return; } try { const expiration = (ttl === 0) ? (Math.floor(Date.now() / 1000) + 365 * 24 * 3600 * 100) : (Math.floor(Date.now() / 1000 + ttl)); const stmt = db.prepare( "INSERT OR REPLACE INTO ip_blacklist (ip, expiration, reason, timestamp) VALUES (?, ?, ?, ?)" ).bind(ip, expiration, reason, Math.floor(Date.now() / 1000)); ctx.waitUntil(stmt.run().then(() => { logSecurityEvent(db, ctx, ip, 'IP_BLACKLISTED', `IP blacklisted for ${reason}. TTL: ${ttl}s.`, null); }).catch(e => console.error(e.message))); } catch (e) { console.error(e.message, e.stack); } } async function checkBlockedIP(db, ip) { if (!db) return null; try { const now = Math.floor(Date.now() / 1000); const stmt = db.prepare("SELECT * FROM ip_blacklist WHERE ip = ?").bind(ip); const entry = await stmt.first(); if (entry && entry.expiration > now) { return entry; } else if (entry && entry.expiration <= now) { db.prepare("DELETE FROM ip_blacklist WHERE ip = ?").bind(ip).run() .catch(e => console.error(e.message)); } return null; } catch (e) { console.error(e.message); return null; } } const byteToHex = Array.from({ length: 256 }, (_, i) => (i + 0x100).toString(16).slice(1)); function unsafeStringify(arr, offset = 0) { return ( byteToHex[arr[offset]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]] ).toLowerCase(); } function stringify(arr, offset = 0) { const uuid = unsafeStringify(arr, offset); if (!isValidUUID(uuid)) { throw new TypeError('Stringified UUID is invalid or malformed: ' + uuid); } return uuid; } 

// Part 2: VLESS Protocol Logic and Connection Handling

async function getUserData(env, uuid, ctx) {
    if (!isValidUUID(uuid)) {
        console.warn(`Invalid UUID format: ${uuid}`);
        return null;
    }
    if (!env.DB) {
        console.error("D1 binding missing. Cannot retrieve user data.");
        return null;
    }

    const cacheKey = `user:${uuid}`;
    let userData = null;

    try {
        userData = await d1KvGet(env.DB, cacheKey, 'json');
        if (userData && userData.uuid) {
            return userData;
        }
    } catch (e) {
        console.error(e.message);
    }

    const userFromDb = await env.DB.prepare("SELECT * FROM users WHERE uuid = ?").bind(uuid).first();

    if (!userFromDb) {
        if (userData) {
            ctx.waitUntil(d1KvDelete(env.DB, cacheKey));
        }
        return null;
    }

    const cachePromise = d1KvPut(env.DB, cacheKey, userFromDb, { expirationTtl: CONST.DB_CACHE_TTL });
    if (ctx) {
        ctx.waitUntil(cachePromise.catch(e => console.error(e.message)));
    } else {
        await cachePromise.catch(e => console.error(e.message));
    }

    return userFromDb;
}

async function updateUsage(env, uuid, bytes, ctx) {
    if (bytes <= 0 || !uuid) return;
    if (!env.DB) {
        console.error("D1 binding missing. Cannot update user usage.");
        return;
    }

    const usageLockKey = `usage_lock:${uuid}`;
    let lockAcquired = false;
    const LOCK_TTL = 5;

    try {
        const maxAttempts = 5;
        for (let i = 0; i < maxAttempts; i++) {
            const existingLock = await d1KvGet(env.DB, usageLockKey);
            if (!existingLock) {
                await d1KvPut(env.DB, usageLockKey, 'locked', { expirationTtl: LOCK_TTL });
                lockAcquired = true;
                break;
            } else {
                await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
            }
        }

        if (!lockAcquired) {
            console.warn(`Failed to acquire lock for ${uuid} after attempts. Skipping usage update.`);
            return;
        }

        const usage = Math.round(bytes);
        const updatePromise = env.DB.prepare(
            "UPDATE users SET traffic_used = traffic_used + ? WHERE uuid = ?"
        ).bind(usage, uuid).run();

        const deleteCachePromise = d1KvDelete(env.DB, `user:${uuid}`);

        if (ctx) {
            ctx.waitUntil(Promise.all([updatePromise, deleteCachePromise])
                .catch(err => console.error(err)));
        } else {
            await Promise.all([updatePromise, deleteCachePromise])
                .catch(err => console.error(err));
        }

    } catch (err) {
        console.error(err.message, err.stack);
    } finally {
        if (lockAcquired) {
            try {
                ctx.waitUntil(d1KvDelete(env.DB, usageLockKey).catch(e => console.error(e.message)));
            } catch (e) {
                console.error(e.message);
            }
        }
    }
}

async function resolveProxyIP(proxyHost) {
    const ipv4Regex = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
    const ipv6Regex = /^\[?([0-9a-fA-F:.]+)\]?$/;
    
    if (ipv4Regex.test(proxyHost) || ipv6Regex.test(proxyHost)) {
        return proxyHost;
    }

    const dnsAPIs = [
        {
            url: `https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(proxyHost)}&type=A`,
            parse: data => data.Answer?.find(a => a.type === 1)?.data
        },
        {
            url: `https://dns.google/resolve?name=${encodeURIComponent(proxyHost)}&type=A`,
            parse: data => data.Answer?.find(a => a.type === 1)?.data
        },
        {
            url: `https://dns.quad9.net/dns-query?name=${encodeURIComponent(proxyHost)}&type=A`,
            parse: data => data.Answer?.find(a => a.type === 1)?.data
        }
    ];

    for (const api of dnsAPIs) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            const response = await fetch(api.url, {
                headers: { 'accept': 'application/dns-json' },
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (response.ok) {
                const data = await response.json();
                const ip = api.parse(data);
                if (ip && ipv4Regex.test(ip)) {
                    return ip;
                }
            }
        } catch (e) {
        }
    }
    console.warn(`Failed to resolve IP for ${proxyHost} after trying all DNS providers. Using original hostname as fallback.`);
    return proxyHost;
}

async function getGeo(ip, cfHeaders = null) {
    if (cfHeaders && (cfHeaders.city || cfHeaders.country || cfHeaders.asOrganization)) {
        return {
            city: cfHeaders.city || '',
            country: cfHeaders.country || '',
            isp: cfHeaders.asOrganization || ''
        };
    }

    const geoAPIs = [
        {
            url: `https://ip-api.com/json/${ip}?fields=status,message,city,country,isp`,
            parse: async (r) => {
                const data = await r.json();
                if (data.status === 'fail') throw new Error(data.message || 'API Error');
                return { city: data.city || '', country: data.country || '', isp: data.isp || '' };
            }
        },
        {
            url: `https://ipapi.co/${ip}/json/`,
            parse: async (r) => {
                const data = await r.json();
                if (data.error) throw new Error(data.reason || 'API Error');
                return { city: data.city || '', country: data.country_name || '', isp: data.org || '' };
            }
        },
        {
            url: `https://ipwho.is/${ip}`,
            parse: async (r) => {
                const data = await r.json();
                if (!data.success) throw new Error('API Error');
                return { city: data.city || '', country: data.country || '', isp: data.connection?.isp || '' };
            }
        },
        {
            url: `https://ipinfo.io/${ip}/json`,
            parse: async (r) => {
                const data = await r.json();
                if (data.bogon) throw new Error('Bogon IP');
                return { city: data.city || '', country: data.country || '', isp: data.org || '' };
            }
        },
        {
            url: `https://freeipapi.com/api/json/${ip}`,
            parse: async (r) => {
                const data = await r.json();
                if (data.message) throw new Error(data.message);
                return { city: data.cityName || '', country: data.countryName || '', isp: '' };
            }
        }
    ];

    for (const api of geoAPIs) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            const response = await fetch(api.url, {
                signal: controller.signal,
                headers: { 'Accept': 'application/json' }
            });
            clearTimeout(timeoutId);

            if (response.ok) {
                const geo = await api.parse(response);
                if (geo && (geo.city || geo.country || geo.isp)) {
                    return geo;
                }
            }
        } catch (e) {
        }
    }

    console.warn(`Failed to get geo-location for IP ${ip} after trying all providers.`);
    return { city: 'Unknown', country: 'Global', isp: 'Unknown' };
}

function generateRandomPath(length = 12) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return `/${result}`;
}

const CORE_PRESETS = {
    xray: {
        tls: {
            path: () => generateRandomPath(12),
            security: 'tls',
            fp: 'chrome',
            alpn: 'http/1.1',
            extra: { ed: '2560' },
        },
        tcp: {
            path: () => generateRandomPath(12),
            security: 'none',
            fp: 'chrome',
            extra: { ed: '2560' },
        },
    },
    sb: {
        tls: {
            path: () => generateRandomPath(18),
            security: 'tls',
            fp: 'firefox',
            alpn: 'h3',
            extra: CONST.ED_PARAMS,
        },
        tcp: {
            path: () => generateRandomPath(18),
            security: 'none',
            fp: 'firefox',
            extra: CONST.ED_PARAMS,
        },
    },
};

function makeName(tag, proto) {
    return `${tag}-${proto.toUpperCase()}`;
}

function randomizeCase(str) {
    if (!str) return str;
    let result = '';
    for (let i = 0; i < str.length; i++) {
        result += Math.random() < 0.5 ? str[i].toUpperCase() : str[i].toLowerCase();
    }
    return result;
}

function createVlessLink({ userID, address, port, host, path, security, sni, fp, alpn, extra = {}, name }) {
    const params = new URLSearchParams({
        encryption: 'none',
        type: 'ws',
        host: host,
        path: path,
    });

    if (security) {
        params.set('security', security);
    }
    if (sni) params.set('sni', sni);
    if (fp) params.set('fp', fp);
    if (alpn) params.set('alpn', alpn);

    for (const [k, v] of Object.entries(extra)) {
        params.set(k, v);
    }

    return `vless://${userID}@${address}:${port}?${params.toString()}#${encodeURIComponent(name)}`;
}

function buildLink({ core, proto, userID, hostName, address, port, tag }) {
    const p = CORE_PRESETS[core]?.[proto];
    if (!p) {
        console.error(`Invalid core or protocol preset requested: core=${core}, proto=${proto}. Falling back to default TLS config.`);
        return createVlessLink({
            userID, address, port, host: hostName, path: generateRandomPath(12),
            security: 'tls', sni: hostName, fp: 'chrome', alpn: 'http/1.1',
            name: makeName(tag, 'DEFAULT_TLS')
        });
    }

    const sniValue = p.security === 'tls' ? randomizeCase(hostName) : undefined;

    return createVlessLink({
        userID,
        address,
        port,
        host: hostName,
        path: p.path(),
        security: p.security,
        sni: sniValue,
        fp: p.fp,
        alpn: p.alpn,
        extra: p.extra,
        name: makeName(tag, proto),
    });
}

const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

async function handleIpSubscription(core, userID, hostName, env) {
    const mainDomains = [
        hostName,
        'www.visa.com', 'www.wto.org', 'creativecommons.org', 'www.speedtest.net',
        'sky.rethinkdns.com', 'cdnjs.com', 'zula.ir', 'go.inmobi.com',
        'mail.tm', 'temp-mail.org', 'ipaddress.my', 'mdbmax.com',
        'check-host.net', 'kodambroker.com', 'iplocation.io', 'whatismyip.org',
        'www.linkedin.com', 'exir.io', 'arzex.io', 'ok-ex.io',
        'arzdigital.com', 'pouyanit.com', 'auth.grok.com', 'grok.com',
        'maxmind.com', 'whatsmyip.com', 'iplocation.net', 'ipchicken.com',
        'showmyip.com', 'router-network.com', 'whatismyipaddress.com',
        'www.apple.com', 'www.microsoft.com', 'www.amazon.com', 'www.cloudflare.com',
        'www.google.com', 'github.com', 'gitlab.com', 'wikipedia.org',
        'developer.mozilla.org', 'www.nginx.com', 'www.apache.org',
        'telegram.org', 'bale.ai', 'ir.linkedin.com', 'divar.ir', 'snapp.ir',
        'jiring.ir', 'shaparak.ir', 'pishgaman.net', 'asriran.com', 'varzesh3.com',
        'isna.ir', 'farsnews.ir', 'mehrnews.com', 'tasnimnews.com'
    ].sort(() => 0.5 - Math.random());

    const httpsPorts = [443, 8443, 2053, 2083, 2087, 2096, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439];
    const httpPorts = [80, 8080, 8880, 2052, 2082, 2086, 2095, 8000, 8008, 8009, 8010, 8011, 8012, 8013, 8014, 8015];

    let links = [];
    const isPagesDeployment = hostName.endsWith('.pages.dev');

    mainDomains.slice(0, 15).forEach((domain, i) => {
        links.push(
            buildLink({ core, proto: 'tls', userID, hostName, address: domain, port: pick(httpsPorts), tag: `D${i + 1}-TLS-1` }),
            buildLink({ core, proto: 'tls', userID, hostName, address: domain, port: pick(httpsPorts), tag: `D${i + 1}-TLS-2` }),
        );
        if (!isPagesDeployment) {
            links.push(
                buildLink({ core, proto: 'tcp', userID, hostName, address: domain, port: pick(httpPorts), tag: `D${i + 1}-TCP-1` }),
                buildLink({ core, proto: 'tcp', userID, hostName, address: domain, port: pick(httpPorts), tag: `D${i + 1}-TCP-2` }),
            );
        }
    });

    let dynamicProxyIPs = [];
    if (env.DB) {
        try {
            const { results } = await env.DB.prepare(
                "SELECT ip_port, latency_ms FROM proxy_health WHERE is_healthy = 1 ORDER BY latency_ms ASC LIMIT 20"
            ).all();
            dynamicProxyIPs = results.map(r => r.ip_port.split(':')[0]);
        } catch (e) {
            console.error(e.message);
        }
    }
    if (dynamicProxyIPs.length === 0) {
        try {
            const r = await fetch(
                'https://raw.githubusercontent.com/NiREvil/vless/refs/heads/main/Cloudflare-IPs.json',
            );
            if (r.ok) {
                const json = await r.json();
                dynamicProxyIPs = [...(json.ipv4 || []), ...(json.ipv6 || [])]
                                .slice(0, 30)
                                .map((x) => x.ip);
            } else {
                console.warn(`Failed to fetch Cloudflare IPs: HTTP Status ${r.status}`);
            }
        } catch (e) {
            console.error(e.message, e.stack);
        }
    }

    dynamicProxyIPs.slice(0, 20).forEach((ip, i) => {
        const formattedAddress = ip.includes(':') ? `[${ip}]` : ip;
        links.push(
            buildLink({ core, proto: 'tls', userID, hostName, address: formattedAddress, port: pick(httpsPorts), tag: `IP${i + 1}-TLS-1` }),
            buildLink({ core, proto: 'tls', userID, hostName, address: formattedAddress, port: pick(httpsPorts), tag: `IP${i + 1}-TLS-2` }),
        );
        if (!isPagesDeployment) {
            links.push(
                buildLink({ core, proto: 'tcp', userID, hostName, address: formattedAddress, port: pick(httpPorts), tag: `IP${i + 1}-TCP-1` }),
                buildLink({ core, proto: 'tcp', userID, hostName, address: formattedAddress, port: pick(httpPorts), tag: `IP${i + 1}-TCP-2` }),
            );
        }
    });

    const uniqueLinks = Array.from(new Set(links)).sort(() => 0.5 - Math.random());

    const headers = new Headers({
        'Content-Type': 'text/plain;charset=utf-8',
        'Profile-Update-Interval': '6',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
    });
    addSecurityHeaders(headers, null, {});

    return new Response(safeBase64Encode(uniqueLinks.join('\n')), { headers });
}

Ultra-Modern Glassmorphism Admin Dashboard (HTML/CSS/JS) and User Panel const adminLoginHTML = `<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Admin Login - VLESS Proxy</title> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet"> <style nonce="CSP_NONCE_PLACEHOLDER"> *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; } body { display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; color: #ffffff; overflow: hidden; position: relative; } body::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at 20% 30%, rgba(59, 130, 246, 0.08) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(168, 85, 247, 0.08) 0%, transparent 50%); pointer-events: none; z-index: -1; animation: backgroundPulse 15s ease-in-out infinite alternate; } @keyframes backgroundPulse { 0% { transform: scale(1); opacity: 0.8; } 100% { transform: scale(1.1); opacity: 0.9; } } .login-container { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 40px; border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1); text-align: center; width: 100%; max-width: 400px; border: 1px solid rgba(255, 255, 255, 0.1); animation: fadeInScale 0.6s ease-out forwards; position: relative; z-index: 1; } @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } } h1 { color: #ffffff; margin-bottom: 24px; font-weight: 600; font-size: 28px; letter-spacing: 1px; background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; } form { display: flex; flex-direction: column; gap: 16px; } input[type="password"], input[type="text"] { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #ffffff; padding: 14px; border-radius: 8px; font-size: 16px; transition: all 0.3s ease; font-family: inherit; } input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); background: rgba(255, 255, 255, 0.15); } input::placeholder { color: rgba(255, 255, 255, 0.5); } button { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; padding: 14px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden; } button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transition: left 0.5s ease; } button:hover::before { left: 100%; } button:hover { transform: translateY(-2px); box-shadow: 0 6px 25px rgba(59, 130, 246, 0.4), 0 0 15px rgba(59, 130, 246, 0.2); } button:active { transform: translateY(0); box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3); } .error { color: #ff6b6b; margin-top: 16px; font-size: 14px; background: rgba(255, 107, 107, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.3); animation: shake 0.5s ease-in-out; } @keyframes shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-5px); } 40%, 80% { transform: translateX(5px); } } @media (max-width: 480px) { .login-container { padding: 30px 20px; margin: 20px; max-width: 90%; } h1 { font-size: 24px; } } </style> </head> <body> <div class="login-container"> <h1>üîê Admin Login</h1> <form method="POST" action="ADMIN_PATH_PLACEHOLDER"> <input type="password" name="password" placeholder="Enter admin password" required autocomplete="current-password"> <input type="text" name="totp" placeholder="2FA Code (if enabled)" autocomplete="off" inputmode="numeric" pattern="[0-9]*" maxlength="6"> <button type="submit">Login</button> </form> </div> </body> </html>`; const adminPanelHTML = `<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Admin Dashboard - VLESS Proxy Manager</title> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet"> <style nonce="CSP_NONCE_PLACEHOLDER"> :root { --bg-main: #0a0e17; --bg-card: #1a1f2e; --border: #2a3441; --text-primary: #F9FAFB; --text-secondary: #9CA3AF; --accent: #3B82F6; --accent-hover: #2563EB; --danger: #EF4444; --danger-hover: #DC2626; --success: #22C55E; --warning: #F59e0b; --info: #06b6d4; --btn-secondary-bg: #4B5563; --purple: #a855f7; --cyan: #06b6d4; --pink: #ec4899; --radius-md: 10px; --radius-lg: 16px; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; background: linear-gradient(135deg, var(--bg-main) 0%, #111827 25%, #0d1321 50%, var(--bg-main) 75%, #111827 100%); background-size: 400% 400%; animation: gradient-flow 15s ease infinite; color: var(--text-primary); font-size: 14px; line-height: 1.6; min-height: 100vh; position: relative; overflow-x: hidden; } body::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at 20% 30%, rgba(59, 130, 246, 0.08) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(168, 85, 247, 0.08) 0%, transparent 50%), radial-gradient(ellipse at 50% 100%, rgba(6, 182, 212, 0.05) 0%, transparent 40%); pointer-events: none; z-index: -1; } @keyframes gradient-flow { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } @keyframes title-shimmer { 0% { background-position: -200% center; } 100% { background-position: 200% center; } } @keyframes pulse-dot { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(0.8); } } @keyframes slideIn { from { transform: translateX(120%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(120%); opacity: 0; } } @keyframes spin { to { transform: rotate(360deg); } } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } .container { max-width: 1400px; margin: 0 auto; padding: 40px 20px; } h1 { font-size: 32px; margin-bottom: 28px; font-weight: 700; background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 30%, var(--cyan) 60%, var(--accent) 100%); background-size: 200% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; animation: title-shimmer 4s linear infinite; text-shadow: 0 0 40px rgba(59, 130, 246, 0.3); text-align: center; } h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); border-bottom: 2px solid transparent; border-image: linear-gradient(90deg, var(--accent), var(--purple), transparent) 1; padding-bottom: 12px; margin-bottom: 20px; position: relative; } .card { background: linear-gradient(145deg, rgba(26, 31, 46, 0.9) 0%, rgba(17, 24, 39, 0.95) 100%); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: var(--radius-lg); padding: 28px; border: 1px solid rgba(255, 255, 255, 0.06); box-shadow: 0 4px 24px rgba(0,0,0,0.2), 0 0 0 1px rgba(255, 255, 255, 0.03), inset 0 1px 0 rgba(255, 255, 255, 0.05); margin-bottom: 24px; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden; } .card::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.03), transparent); transition: left 0.6s ease; } .card:hover::before { left: 100%; } .card:hover { box-shadow: 0 20px 40px rgba(0,0,0,0.3), 0 0 80px rgba(59, 130, 246, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.1); border-color: rgba(59, 130, 246, 0.3); transform: translateY(-4px); } .dashboard-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 30px; } .stat-card { background: linear-gradient(145deg, rgba(26, 31, 46, 0.9) 0%, rgba(17, 24, 39, 0.95) 100%); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); padding: 24px 20px; border-radius: var(--radius-lg); text-align: center; border: 1px solid rgba(255, 255, 255, 0.05); transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden; box-shadow: 0 4px 16px rgba(0,0,0,0.15); } .stat-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, var(--accent), var(--purple), var(--cyan)); opacity: 0; transition: opacity 0.3s; } .stat-card::after { content: ''; position: absolute; inset: 0; background: radial-gradient(circle at 50% 0%, rgba(59, 130, 246, 0.1) 0%, transparent 70%); opacity: 0; transition: opacity 0.4s; } .stat-card:hover::before { opacity: 1; } .stat-card:hover::after { opacity: 1; } .stat-card:hover { transform: translateY(-6px) scale(1.02); box-shadow: 0 20px 40px rgba(59, 130, 246, 0.2), 0 0 0 1px rgba(59, 130, 246, 0.2); border-color: rgba(59, 130, 246, 0.3); } .stat-card.healthy { --card-accent: var(--success); } .stat-card.warning { --card-accent: var(--warning); } .stat-card.danger { --card-accent: var(--danger); } .stat-card.healthy::before, .stat-card.warning::before, .stat-card.danger::before { background: var(--card-accent); opacity: 1; } .stat-icon { width: 44px; height: 44px; border-radius: 10px; display: flex; align-items: center; justify-content: center; margin: 0 auto 12px; font-size: 20px; color: var(--text-primary); } .stat-icon.blue { background: rgba(59, 130, 246, 0.15); } .stat-icon.green { background: rgba(34, 197, 94, 0.15); } .stat-icon.orange { background: rgba(245, 158, 11, 0.15); } .stat-icon.purple { background: rgba(168, 85, 247, 0.15); } .stat-icon.red { background: rgba(239, 68, 68, 0.15); color: var(--danger); } .stat-value { font-size: 28px; font-weight: 700; color: var(--accent); margin-bottom: 6px; line-height: 1.2; transition: color 0.3s; } .stat-card.healthy .stat-value { color: var(--success); } .stat-card.warning .stat-value { color: var(--warning); } .stat-card.danger .stat-value { color: var(--danger); } .stat-label { font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; } .stat-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; margin-top: 8px; } .stat-badge.online { background: rgba(34, 197, 94, 0.15); color: var(--success); } .stat-badge.offline { background: rgba(239, 68, 68, 0.15); color: var(--danger); } .stat-badge.checking { background: rgba(245, 158, 11, 0.15); color: var(--warning); } .stat-badge.threat { background: rgba(239, 68, 68, 0.15); color: var(--danger); } .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; align-items: flex-end; } .form-group { display: flex; flex-direction: column; position: relative; } .form-group label { margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); font-size: 13px; } input[type="text"], input[type="date"], input[type="time"], input[type="number"], input[type="password"], select, textarea { width: 100%; background: #374151; border: 1px solid #4B5563; color: var(--text-primary); padding: 12px; border-radius: var(--radius-md); font-size: 14px; transition: all 0.2s ease; font-family: inherit; } input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); } input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; } input[type="number"] { -moz-appearance: textfield; } .btn { padding: 12px 22px; border: none; border-radius: var(--radius-md); font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: inline-flex; align-items: center; justify-content: center; gap: 8px; font-size: 14px; position: relative; overflow: hidden; text-decoration: none; } .btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transition: left 0.5s ease; } .btn:hover::before { left: 100%; } .btn:active { transform: scale(0.96); } .btn-primary { background: linear-gradient(135deg, var(--accent) 0%, #6366f1 50%, var(--purple) 100%); background-size: 200% 200%; color: white; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3); } .btn-primary:hover { background-position: 100% 50%; box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5); transform: translateY(-3px); } .btn-secondary { background: linear-gradient(135deg, #4B5563 0%, #374151 100%); color: white; border: 1px solid rgba(255,255,255,0.08); } .btn-secondary:hover { background: linear-gradient(135deg, #6B7280 0%, #4B5563 100%); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); } .btn-danger { background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%); color: white; box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3); } .btn-danger:hover { box-shadow: 0 8px 25px rgba(239, 68, 68, 0.5); transform: translateY(-3px); } .btn-outline-secondary { background: transparent; border: 1px solid var(--btn-secondary-bg); color: var(--text-secondary); padding: 6px 12px; font-size: 12px; border-radius: var(--radius-md); } .btn-outline-secondary:hover { background: var(--btn-secondary-bg); color: white; transform: translateY(-1px); } .table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; border-radius: var(--radius-md); border: 1px solid rgba(255, 255, 255, 0.06); box-shadow: inset 0 0 10px rgba(0,0,0,0.1); } table { width: 100%; border-collapse: collapse; min-width: 800px; } th, td { padding: 14px 16px; text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.04); } td.actions { white-space: nowrap; } th { color: var(--text-secondary); font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; background: rgba(59, 130, 246, 0.08); position: sticky; top: 0; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index: 10; } td { color: var(--text-primary); font-size: 13px; transition: background 0.2s ease; } tbody tr { transition: all 0.2s ease; } tbody tr:hover { background: rgba(59, 130, 246, 0.08); } tbody tr:last-child td { border-bottom: none; } .status-badge { padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; display: inline-block; } .status-active { background: rgba(34, 197, 94, 0.2); color: var(--success); border: 1px solid var(--success); } .status-expired { background: rgba(239, 68, 68, 0.2); color: var(--danger); border: 1px solid var(--danger); } .status-blocked { background: rgba(239, 68, 68, 0.2); color: var(--danger); border: 1px solid var(--danger); } .status-warning-light { background: rgba(245, 158, 11, 0.15); color: var(--warning); } .uuid-cell { display: flex; align-items: center; gap: 8px; } .btn-copy-uuid { padding: 4px 8px; font-size: 11px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); color: var(--accent); border-radius: 4px; cursor: pointer; transition: all 0.2s ease; } .btn-copy-uuid:hover { background: rgba(59, 130, 246, 0.2); border-color: var(--accent); } .btn-copy-uuid.copied { background: rgba(34, 197, 94, 0.2); border-color: var(--success); color: var(--success); } #toast { position: fixed; top: 20px; right: 20px; background: rgba(31, 41, 55, 0.95); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); color: white; padding: 16px 20px; border-radius: var(--radius-md); z-index: 1001; display: none; border: 1px solid rgba(255, 255, 255, 0.08); box-shadow: 0 12px 32px rgba(0,0,0,0.4); animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1); min-width: 280px; max-width: 400px; } .toast-content { display: flex; align-items: center; gap: 12px; } .toast-icon { width: 32px; height: 32px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; color: var(--text-primary); } .toast-icon.success { background: rgba(34, 197, 94, 0.15); } .toast-icon.error { background: rgba(239, 68, 68, 0.15); } .toast-icon.warning { background: rgba(245, 158, 11, 0.15); } .toast-icon.info { background: rgba(6, 182, 212, 0.15); } .toast-message { flex: 1; font-size: 14px; line-height: 1.4; } #toast.show { display: block; } #toast.hide { animation: slideOut 0.3s ease forwards; } #toast.success { border-left: 4px solid var(--success); } #toast.error { border-left: 4px solid var(--danger); } #toast.warning { border-left: 4px solid var(--warning); } #toast.info { border-left: 4px solid var(--info); } .btn.loading { pointer-events: none; opacity: 0.7; position: relative; } .btn.loading::after { content: ''; position: absolute; width: 16px; height: 16px; border: 2px solid transparent; border-top-color: currentColor; border-radius: 50%; animation: spin 0.8s linear infinite; right: 12px; } .pulse-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; animation: pulse-dot 2s ease-in-out infinite; } .pulse-dot.green { background: var(--success); box-shadow: 0 0 8px var(--success); } .pulse-dot.red { background: var(--danger); box-shadow: 0 0 8px var(--danger); } .pulse-dot.orange { background: var(--warning); box-shadow: 0 0 8px var(--warning); } .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: all 0.3s ease-in-out; } .modal-overlay.show { opacity: 1; visibility: visible; } .modal-content { background: var(--bg-card); padding: 32px; border-radius: var(--radius-lg); box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 0 1px var(--border); width: 90%; max-width: 600px; max-height: 90vh; overflow-y: auto; transform: scale(0.9); transition: transform 0.3s ease-in-out; position: relative; } .modal-overlay.show .modal-content { transform: scale(1); } .modal-close-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 24px; color: var(--muted); cursor: pointer; transition: color 0.2s; z-index: 10; } .modal-close-btn:hover { color: var(--text-primary); } .search-input { width: 100%; margin-bottom: 16px; padding: 12px 16px; background: #374151; border: 1px solid #4B5563; color: var(--text-primary); border-radius: var(--radius-md); font-size: 14px; font-family: inherit; } .time-quick-set-group { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; } .header-actions { position: absolute; top: 20px; right: 20px; display: flex; gap: 12px; z-index: 50; } .log-type-badge { padding: 4px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; } .log-type-badge.BRUTE_FORCE_LOGIN { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.INVALID_UUID_ATTEMPT { background: rgba(245, 158, 11, 0.2); color: var(--warning); } .log-type-badge.PORT_SCAN_ATTEMPT { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.IP_BLACKLISTED { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.ADMIN_LOGIN_SUCCESS { background: rgba(59, 130, 246, 0.2); color: var(--accent); } .log-type-badge.ADMIN_LOGIN_ERROR { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.ADMIN_ACCESS_DENIED { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.ADMIN_API_RATE_LIMIT { background: rgba(245, 158, 11, 0.2); color: var(--warning); } .log-type-badge.CSRF_ATTEMPT { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.VLESS_ACCESS_DENIED { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.UNSUPPORTED_UDP { background: rgba(245, 158, 11, 0.2); color: var(--warning); } .log-type-badge.HEALTH_CHECK_TRIGGERED { background: rgba(6, 182, 212, 0.2); color: var(--info); } .log-type-badge.USER_CREATED { background: rgba(34, 197, 94, 0.2); color: var(--success); } .log-type-badge.USER_UPDATED { background: rgba(59, 130, 246, 0.2); color: var(--accent); } .log-type-badge.USER_DELETED { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.USER_BULK_DELETED { background: rgba(239, 68, 68, 0.2); color: var(--danger); } .log-type-badge.IP_WHITELISTED { background: rgba(34, 197, 94, 0.2); color: var(--success); } .security-tabs { display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 10px; } .security-tab-btn { padding: 8px 15px; border-radius: 8px; font-weight: 500; cursor: pointer; background: transparent; border: 1px solid transparent; color: var(--text-secondary); transition: all 0.2s ease; } .security-tab-btn.active { background: var(--accent); color: var(--text-primary); border-color: var(--accent); box-shadow: 0 2px 10px rgba(59, 130, 246, 0.2); } .security-tab-btn:hover:not(.active) { background: rgba(255,255,255,0.05); color: var(--text-primary); } .tab-content { animation: fadeIn 0.4s ease-out; } .hidden { display: none !important; } .filter-group { display: flex; gap: 10px; margin-bottom: 16px; flex-wrap: wrap; align-items: center; } .filter-group label { font-size: 13px; color: var(--text-secondary); } @media (max-width: 768px) { .container { padding: 20px 12px; } h1 { font-size: 24px; } .header-actions { position: static; margin-top: 20px; margin-bottom: 20px; justify-content: flex-end; } .dashboard-stats { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); } .form-grid { grid-template-columns: 1fr; } table { min-width: unset; } th, td { padding: 10px 12px; } .btn { padding: 10px 16px; font-size: 13px; } .stat-value { font-size: 24px; } .stat-label { font-size: 10px; } .security-tabs { flex-wrap: wrap; justify-content: center; } .filter-group { flex-direction: column; align-items: flex-start; } } </style> </head> <body> <div class="container"> <h1>üöÄ VXR.SXR Configuration Panel</h1> <p class="lead">Manage your proxy configuration, view subscription links, and monitor usage statistics.</p> <div class="stats"> <div class="stat USER_PANEL_STATUS_CLASS"> <div class="val" id="status-badge">USER_PANEL_STATUS_TEXT</div> <div class="lbl">Account Status</div> </div> <div class="stat"> <div class="val" id="usage-display">0 KB</div> <div class="lbl">Data Used</div> </div> <div class="stat USER_PANEL_DATALIMIT_WARNING_CLASS"> <div class="val" id="data-limit-display">Unlimited</div> <div class="lbl">Data Limit</div> </div> <div class="stat"> <div class="val" id="expiry-countdown">‚Äî</div> <div class="lbl">Time Remaining</div> </div> </div> <div class="widgets-grid"> <div class="widget"> <div class="widget-header"> <div class="widget-title"> <div class="widget-icon green">üìä</div> <span>Live Traffic</span> </div> <div class="pulse-indicator"></div> </div> <div class="traffic-speeds"> <div class="traffic-speed"> <div class="traffic-speed-icon down">‚Üì</div> <div> <div class="traffic-speed-value" id="live-download">0.00</div> <div class="traffic-speed-unit">MB/s Download</div> </div> </div> <div class="traffic-speed"> <div class="traffic-speed-icon up">‚Üë</div> <div> <div class="traffic-speed-value" id="live-upload">0.00</div> <div class="traffic-speed-unit">KB/s Upload</div> </div> </div> </div> <div class="traffic-graph"> <div class="traffic-graph-line"></div> </div> <div class="traffic-stats"> <div class="traffic-stat"> <div class="traffic-stat-val" id="total-down-stat">0 KB</div> <div class="traffic-stat-lbl">Total Down</div> </div> <div class="traffic-stat"> <div class="traffic-stat-val" id="total-up-stat">‚Äî</div> <div class="traffic-stat-lbl">Total Up</div> </div> <div class="traffic-stat"> <div class="traffic-stat-val" id="connections-stat">1</div> <div class="traffic-stat-lbl">Connections</div> </div> <div class="traffic-stat"> <div class="traffic-stat-val" id="packet-loss-stat">0%</div> <div class="traffic-stat-lbl">Packet Loss</div> </div> </div> </div> <div class="widget"> <div class="widget-header"> <div class="widget-title"> <div class="widget-icon red">‚ù§Ô∏è</div> <span>Connection Health</span> </div> <div class="widget-badge USER_PANEL_HEALTH_BADGE_CLASS" id="health-badge">USER_PANEL_HEALTH_BADGE_TEXT</div> </div> <div class="health-row"> <div class="health-item"> <div class="health-item-icon" style="background:rgba(245,158,11,0.12);color:var(--warning)">‚è±</div> <div> <div class="health-item-val" id="latency-val">--ms</div> <div class="health-item-lbl">Latency</div> </div> </div> <div class="health-item"> <div class="health-item-icon" style="background:rgba(59,130,246,0.12);color:var(--accent)">‚è∞</div> <div> <div class="health-item-val" id="uptime-val">0h 0m</div> <div class="health-item-lbl">Uptime</div> </div> </div> </div> <div style="margin-top:8px"> <div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:12px"> <span style="color:var(--muted)">Connection Stability</span> <span style="color:var(--success)" id="stability-pct">--%</span> </div> <div class="stability-bar"> <div class="stability-fill" id="stability-fill" style="width:0%"></div> </div> </div> </div> <div class="widget"> <div class="widget-header"> <div class="widget-title"> <div class="widget-icon purple">üìà</div> <span>Network Statistics</span> </div> </div> <div class="net-stats-grid"> <div class="net-stat"> <div class="net-stat-icon" style="background:rgba(245,158,11,0.12);color:var(--warning)">üì∂</div> <div> <div class="net-stat-val" id="net-latency">--</div> <div class="net-stat-lbl">Latency (ms)</div> </div> </div> <div class="net-stat"> <div class="net-stat-icon" style="background:rgba(59,130,246,0.12);color:var(--accent)">„Ä∞Ô∏è</div> <div> <div class="net-stat-val" id="net-jitter">--</div> <div class="net-stat-lbl">Jitter (ms)</div> </div> </div> <div class="net-stat"> <div class="net-stat-icon" style="background:rgba(34,197,94,0.12);color:var(--success)">üì•</div> <div> <div class="net-stat-val" id="packets-in">--</div> <div class="net-stat-lbl">Packets In</div> </div> </div> <div class="net-stat"> <div class="net-stat-icon" style="background:rgba(168,85,247,0.12);color:#a855f7">üì§</div> <div> <div class="net-stat-val" id="packets-out">--</div> <div class="net-stat-lbl">Packets Out</div> </div> </div> </div> </div> </div> <div class="card" style="margin-bottom:20px"> <div class="widget-header" style="margin-bottom:10px;padding-bottom:0;border:none"> <div class="analytics-tabs"> <button class="analytics-tab active" data-tab="analytics">üìä Analytics</button> <button class="analytics-tab" data-tab="history">üìú History</button> </div> </div> <div id="analytics-content" class="tab-content"> <div class="analytics-grid"> <div class="analytics-item"> <div class="analytics-item-val" id="analytics-total-download">0 KB</div> <div class="analytics-item-lbl">Total Download</div> </div> <div class="analytics-item"> <div class="analytics-item-val" id="analytics-total-upload">‚Äî</div> <div class="analytics-item-lbl">Total Upload</div> </div> <div class="analytics-item"> <div class="analytics-item-val" id="analytics-avg-latency">--ms</div> <div class="analytics-item-lbl">Avg Latency</div> </div> <div class="analytics-item"> <div class="analytics-item-val" id="analytics-connections">--</div> <div class="analytics-item-lbl">Connections</div> </div> </div> </div> <div id="history-content" class="tab-content hidden"> <div style="text-align:center;padding:20px;color:var(--muted)"> <div class="loading-spinner"></div> <p>Loading connection history...</p> <p style="font-size:13px;margin-top:8px;opacity:0.7">Recent session data and activity logs.</p> </div> </div> </div> <div id="usage-stats-card" class="card hidden"> <div class="section-title"> <h2>üìä Usage Statistics</h2> <span class="muted" id="usage-percentage">0.00% Used</span> </div> <div class="progress-bar"> <div class="progress-fill low" id="progress-bar-fill" data-target-width="0"></div> </div> <p class="muted text-center mb-2" id="usage-text">0 KB of Unlimited used</p> </div> <div id="expiration-card" class="card hidden"> <div class="section-title"> <h2>‚è∞ Expiration Information</h2> </div> <div id="expiration-display" data-expiry=""> <p class="muted" id="expiry-local">Loading...</p> <p class="muted" id="expiry-utc"></p> </div> <div class="expiry-info" id="expiry-status-message"> </div> </div> <div class="main-grid"> <div> <div class="card"> <div class="section-title"> <h2>üåê Network Information</h2> <button class="btn ghost small" data-action="refresh">üîÑ Refresh</button> </div> <p class="muted">Connection details and IP information.</p> <div class="info-grid"> <div class="info-item"> <span class="label">Proxy Host</span> <span class="value" id="info-proxy-host">--</span> </div> <div class="info-item"> <span class="label">Proxy IP</span> <span class="value" id="info-proxy-ip">--</span> </div> <div class="info-item"> <span class="label">Proxy Location</span> <span class="value" id="info-proxy-location">--</span> </div> <div class="info-item"> <span class="label">Your IP</span> <span class="value" id="info-client-ip">--</span> </div> <div class="info-item"> <span class="label">Your Location</span> <span class="value" id="info-client-location">--</span> </div> <div class="info-item"> <span class="label">Your ISP</span> <span class="value" id="info-client-isp">--</span> </div> </div> </div> <div class="card"> <div class="section-title"> <h2>üì± Subscription Links</h2> </div> <p class="muted">Copy subscription URLs or import directly.</p> <div class="stack"> <div> <h3 class="config-subheader">Xray / V2Ray Subscription</h3> <div class="buttons"> <button class="btn primary" data-action="copy-sub" data-url-type="xray">üìã Copy Sub Link</button> <button class="btn ghost" data-action="copy-config" data-config-type="xray">üìã Copy Config</button> <button class="btn ghost" data-action="toggle-config-view" data-target="xray-config-view">View Config</button> <button class="btn ghost" data-action="open-qr-modal" data-config-type="xray">üì± QR Code</button> </div> <pre class="config hidden" id="xray-config-view"></pre> </div> <div> <h3 class="config-subheader">Sing-Box / Clash Subscription</h3> <div class="buttons"> <button class="btn primary" data-action="copy-sub" data-url-type="singbox">üìã Copy Sub Link</button> <button class="btn ghost" data-action="copy-config" data-config-type="singbox">üìã Copy Config</button> <button class="btn ghost" data-action="toggle-config-view" data-target="sb-config-view">View Config</button> <button class="btn ghost" data-action="open-qr-modal" data-config-type="singbox">üì± QR Code</button> </div> <pre class="config hidden" id="sb-config-view"></pre> </div> <div> <h3 class="config-subheader">Quick Import</h3> <div class="buttons"> <a href="#" class="btn ghost" data-action="direct-import" data-client="v2rayng">üì± Android (V2rayNG)</a> <a href="#" class="btn ghost" data-action="direct-import" data-client="shadowrocket">üçé iOS (Shadowrocket)</a> <a href="#" class="btn ghost" data-action="direct-import" data-client="streisand">üçé iOS Streisand</a> <a href="#" class="btn ghost" data-action="direct-import" data-client="karing">üîß Karing</a> <a href="#" class="btn ghost" data-action="direct-import" data-client="clashMeta">üåê Clash Meta</a> <a href="#" class="btn ghost" data-action="direct-import" data-client="exclave">üì¶ Exclave</a> </div> </div> </div> </div> </div> <aside> <div class="card"> <h2>üë§ Account Details</h2> <div class="info-item" style="margin-top:12px;"> <span class="label">User UUID</span> <span class="value" id="account-uuid">--</span> </div> <div class="info-item" style="margin-top:12px;"> <span class="label">Created Date</span> <span class="value" id="account-created">--</span> </div> <div class="info-item" style="margin-top:12px;" id="account-notes-container"> <span class="label">Notes</span> <span class="value" id="account-notes">--</span> </div> <div class="info-item" style="margin-top:12px;"> <span class="label">IP Limit</span> <span class="value" id="account-ip-limit">--</span> </div> </div> <div class="card"> <h2>üíæ Export Configuration</h2> <p class="muted mb-2">Download configuration for manual import or backup.</p> <div class="buttons"> <button class="btn primary small" data-action="download-config" data-type="xray">Download Xray Config</button> <button class="btn primary small" data-action="download-config" data-type="singbox">Download Singbox Config</button> </div> </div> </aside> </div> <div class="card"> <p class="muted text-center" style="margin:0;"> üîí This is your personal configuration panel. Keep your subscription links private and secure. <br>For support, contact your service administrator. </p> </div> <div id="toast"></div> </div> <div id="qrModal" class="modal-overlay"> <div class="modal-content"> <button class="modal-close-btn" data-action="close-modal">‚úï</button> <h2>üì± Scan QR Code</h2> <p class="muted mb-2" id="qr-modal-description">Scan this code with your VLESS client (e.g., V2rayNG, Shadowrocket) to quickly import your configuration.</p> <div id="qr-display" class="text-center"> <div class="loading-spinner"></div> <p class="muted" style="margin-top:10px;">Generating QR Code...</p> </div> <div class="qr-download-links"> <a href="#" id="qr-direct-link" class="btn ghost" download="vless_config.txt">üîó Download Config File</a> <a href="#" id="qr-download-image" class="btn ghost" download="vless_qrcode.png">üñºÔ∏è Download QR Image</a> </div> </div> </div> <script nonce="CSP_NONCE_PLACEHOLDER"> window.CONFIG = { uuid: "USER_UUID_PLACEHOLDER", host: "WORKER_HOSTNAME_PLACEHOLDER", proxyAddress: "PROXY_ADDRESS_PLACEHOLDER", clientIp: "CLIENT_IP_PLACEHOLDER", clientGeo: { city: "CLIENT_CITY_PLACEHOLDER", country: "CLIENT_COUNTRY_PLACEHOLDER", isp: "CLIENT_ISP_PLACEHOLDER" }, proxyGeo: { city: "PROXY_CITY_PLACEHOLDER", country: "PROXY_COUNTRY_PLACEHOLDER", isp: "PROXY_ISP_PLACEHOLDER" }, subXrayUrl: "SUB_XRAY_URL_PLACEHOLDER", subSbUrl: "SUB_SB_URL_URL_PLACEHOLDER", singleXrayConfig: "SINGLE_XRAY_CONFIG_PLACEHOLDER", singleSingboxConfig: "SINGLE_SINGBOX_CONFIG_PLACEHOLDER", expirationDateTime: "EXPIRATION_DATE_TIME_PLACEHOLDER", isExpired: IS_EXPIRED_PLACEHOLDER, trafficLimit: TRAFFIC_LIMIT_PLACEHOLDER, initialTrafficUsed: INITIAL_TRAFFIC_USED_PLACEHOLDER, notes: "NOTES_PLACEHOLDER", ipLimit: IP_LIMIT_PLACEHOLDER, }; async function formatBytes(bytes) { if (bytes === 0 || bytes === null || bytes === undefined) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i))).toFixed(2) + ' ' + sizes[i]; } function showToast(message, type = 'success', duration = 3000) { const toast = document.getElementById('toast'); if (!toast) { console.warn('Toast element not found.'); return; } const icons = { success: '‚úì', error: '‚úï', warning: '‚ö†', info: '‚Ñπ' }; const icon = icons[type] || icons.success; const actualType = message.startsWith('‚úì') ? 'success' : message.startsWith('‚ö†Ô∏è') ? 'warning' : message.startsWith('‚ùå') ? 'error' : type; toast.innerHTML = `<div class="toast-content"><div class="toast-icon ${actualType}"><span>${icon}</span></div><div class="toast-message">${message}</div></div>`; toast.className = `${actualType} show`; setTimeout(() => { toast.classList.add('hide'); setTimeout(() => { toast.className = ''; toast.style.display = 'none'; }, 300); }, duration); toast.style.display = 'block'; } function switchTab(el, tab) { document.querySelectorAll('.analytics-tab').forEach(t => t.classList.remove('active')); el.classList.add('active'); document.getElementById('analytics-content').classList.toggle('hidden', tab !== 'analytics'); document.getElementById('history-content').classList.toggle('hidden', tab !== 'history'); } let sessionStartTime = Date.now(); let simulatedUploadBytes = 0; const initialTrafficUsed = window.CONFIG.initialTrafficUsed || 0; function updateUptime() { const elapsed = Date.now() - sessionStartTime; const hours = Math.floor(elapsed / 3600000); const minutes = Math.floor((elapsed % 3600000) / 60000); const uptimeEl = document.getElementById('uptime-val'); if (uptimeEl) uptimeEl.textContent = `${hours}h ${minutes}m`; } async function updateUploadStats() { simulatedUploadBytes = Math.floor(initialTrafficUsed * (0.30 + Math.random() * 0.10)); const uploadFormatted = await formatBytes(simulatedUploadBytes); const totalUpStatEl = document.getElementById('total-up-stat'); if (totalUpStatEl) totalUpStatEl.innerHTML = `${uploadFormatted} <span style="font-size:9px;opacity:0.6">(Est.)</span>`; const analyticsTotalUploadEl = document.getElementById('analytics-total-upload'); if (analyticsTotalUploadEl) analyticsTotalUploadEl.innerHTML = `${uploadFormatted} <span style="font-size:9px;opacity:0.6">(Est.)</span>`; } function simulateLiveStats() { const dlEl = document.getElementById('live-download'); const ulEl = document.getElementById('live-upload'); if (dlEl) dlEl.textContent = (Math.random() * 2.5 + 0.1).toFixed(2); if (ulEl) ulEl.textContent = (Math.random() * 150 + 10).toFixed(0); const latency = Math.floor(Math.random() * 20 + 35); const latencyEl = document.getElementById('latency-val'); const netLatencyEl = document.getElementById('net-latency'); const analyticsAvgLatencyEl = document.getElementById('analytics-avg-latency'); if (latencyEl) latencyEl.textContent = `${latency}ms`; if (netLatencyEl) netLatencyEl.textContent = latency; if (analyticsAvgLatencyEl) analyticsAvgLatencyEl.textContent = `${latency}ms`; const jitterEl = document.getElementById('net-jitter'); if (jitterEl) jitterEl.textContent = Math.floor(Math.random() * 5 + 1); const stabilityPctEl = document.getElementById('stability-pct'); const stabilityFillEl = document.getElementById('stability-fill'); const currentStability = parseFloat(stabilityPctEl?.textContent) || 90; const newStability = Math.min(100, Math.max(85, currentStability + (Math.random() - 0.5) * 5)).toFixed(0); if (stabilityPctEl) stabilityPctEl.textContent = `${newStability}%`; if (stabilityFillEl) stabilityFillEl.style.width = `${newStability}%`; const connectionsStatEl = document.getElementById('connections-stat'); if (connectionsStatEl) connectionsStatEl.textContent = Math.floor(Math.random() * 5 + 1); const packetLossStatEl = document.getElementById('packet-loss-stat'); if (packetLossStatEl) packetLossStatEl.textContent = `${(Math.random() * 0.5).toFixed(1)}%`; const packetsInEl = document.getElementById('packets-in'); const packetsOutEl = document.getElementById('packets-out'); if (packetsInEl) packetsInEl.textContent = `${(Math.random() * 20 + 5).toFixed(1)}K`; if (packetsOutEl) packetsOutEl.textContent = `${(Math.random() * 15 + 3).toFixed(1)}K`; const analyticsConnectionsEl = document.getElementById('analytics-connections'); if (analyticsConnectionsEl) analyticsConnectionsEl.textContent = connectionsStatEl.textContent; } let QR_LAST_TEXT = ''; function cleanConfigString(text) { if (!text || typeof text !== 'string') return ''; let cleaned = text.trim(); cleaned = cleaned.replace(/^<pre[^>]*>/i, '').replace(/<\/pre>$/i, ''); cleaned = cleaned.replace(/^<code[^>]*>/i, '').replace(/<\/code>$/i, ''); cleaned = cleaned.trim(); if ((cleaned.startsWith('"') && cleaned.endsWith('"')) || (cleaned.startsWith("'") && cleaned.endsWith("'"))) { cleaned = cleaned.slice(1, -1).trim(); } if (/^vmess:\/\//i.test(cleaned)) { try { const protocol = 'vmess://'; const payload = cleaned.slice(protocol.length); const cleanPayload = payload.replace(/\s+/g, ''); if (/^[A-Za-z0-9+\/=]+$/.test(cleanPayload)) { try { const decoded = atob(cleanPayload); const json = JSON.parse(decoded); const standardJson = { v: json.v || "2", ps: json.ps || "Config", add: json.add || "", port: json.port || "443", id: json.id || "", aid: json.aid || "0", net: json.net || "ws", type: json.type || "none", host: json.host || "", path: json.path || "/", tls: json.tls || "tls", sni: json.sni || "", fp: json.fp || "chrome" }; const reencoded = btoa(JSON.stringify(standardJson)); return protocol + reencoded; } catch (e) { return protocol + cleanPayload; } } } catch (e) { console.warn('VMESS cleaning error:', e.message); } } else if (/^(vless|trojan|ss):\/\//i.test(cleaned)) { cleaned = cleaned.replace(/\r?\n/g, '').replace(/\s+/g, ' ').trim(); } else if (/^\s*\{/.test(cleaned) && /\}\s*$/.test(cleaned)) { try { const parsed = JSON.parse(cleaned); if (parsed.v || parsed.id || parsed.add) { const encoded = btoa(JSON.stringify(parsed)); return 'vmess://' + encoded; } } catch (e) { cleaned = cleaned.replace(/\s+/g, ''); } } else { cleaned = cleaned.replace(/\r?\n/g, '').trim(); } return cleaned.trim(); } function validateOptimizedPayload(text) { if (!text || typeof text !== 'string' || text.length === 0) return { valid: false, message: 'Empty configuration payload.' }; const t = cleanConfigString(text); if (/^vmess:\/\//i.test(t)) { try { const payload = t.slice(8); const decoded = atob(payload.replace(/-/g, '+').replace(/_/g, '/')); const config = JSON.parse(decoded); if (!config.id || !config.add || !config.port) { return { valid: false, message: 'VMess config incomplete (missing id, address, or port).' }; } return { valid: true }; } catch (e) { return { valid: false, message: 'Invalid VMess base64 or JSON format.' }; } } if (/^vless:\/\//i.test(t)) { const vlessRegex = /^vless:\/\/([^@]+)@([^:]+):(\d+)/; if (!vlessRegex.test(t)) { return { valid: false, message: 'Invalid VLESS URI format.' }; } return { valid: true }; } if (/^(ss|trojan):\/\//i.test(t)) { if (!t.includes('@') && !t.includes('://')) { return { valid: false, message: 'Invalid Shadowsocks/Trojan URI format.' }; } return { valid: true }; } return { valid: true, message: 'Unknown protocol, assuming valid raw data.' }; } function generateQRCode(text) { const qrModal = document.getElementById('qrModal'); const qrDisplay = document.getElementById('qr-display'); const qrDownloadImageLink = document.getElementById('qr-download-image'); const qrDirectLink = document.getElementById('qr-direct-link'); const qrModalDescription = document.getElementById('qr-modal-description'); if (!qrModal || !qrDisplay || !qrDownloadImageLink || !qrDirectLink || !qrModalDescription) { console.error('One or more QR modal elements not found.'); showToast('Error: QR modal components missing.', 'error'); return; } qrDisplay.innerHTML = `<div class="loading-spinner"></div><p class="muted" style="margin-top:10px;">Generating QR Code...</p>`; qrDownloadImageLink.classList.add('hidden'); qrDirectLink.classList.add('hidden'); qrModal.classList.add('show'); text = cleanConfigString(text); if (!text || text.length === 0) { qrDisplay.innerHTML = '<p style="color:var(--danger)">Empty configuration - cannot generate QR</p>'; qrModalDescription.textContent = 'Configuration is empty. Cannot generate QR code.'; showToast('Configuration is empty.', 'error'); return; } QR_LAST_TEXT = text; setTimeout(() => { qrDisplay.innerHTML = ''; const validation = validateOptimizedPayload(text); if (!validation.valid) { qrModalDescription.innerHTML = `<p style="color:var(--danger)">‚ö†Ô∏è Validation Warning: ${validation.message} QR code might not work.</p>`; showToast('‚ö†Ô∏è Validation: ' + validation.message, 'warning'); } else { qrModalDescription.textContent = 'Scan this code with your VLESS client (e.g., V2rayNG, Shadowrocket) to quickly import your configuration.'; } let generatedImage = null; try { const canvas = QRCodeGenerator.generate(text, 256); if (canvas) { qrDisplay.appendChild(canvas); generatedImage = canvas.toDataURL('image/png'); showToast('‚úì QR Code Generated (Embedded)', 'success'); } } catch (e) { console.warn('Embedded QR failed, trying CDN fallback:', e.message); } if (!generatedImage && typeof QRCode !== 'undefined' && window.QRCode) { try { const qrcodejsDiv = document.createElement('div'); qrDisplay.appendChild(qrcodejsDiv); new QRCode(qrcodejsDiv, { text: text, width: 256, height: 256, colorDark: "#000000", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.M }); const imgEl = qrcodejsDiv.querySelector('img') || qrcodejsDiv.querySelector('canvas'); if (imgEl) { generatedImage = imgEl.toDataURL('image/png'); showToast('‚úì QR Code Generated (CDN Fallback)', 'success'); } } catch (cdnErr) { console.warn('CDN qrcode.js failed, trying Google Charts:', cdnErr.message); } } if (!generatedImage) { try { const encoded = encodeURIComponent(text); const googleChartsUrl = 'https://chart.googleapis.com/chart?cht=qr&chl=' + encoded + '&chs=256x256&choe=UTF-8&chld=M|0'; if (googleChartsUrl.length > 2000) { qrDisplay.innerHTML = '<p style="color:var(--danger)">‚ö†Ô∏è Configuration content too large for QR code generation. Please use "Copy Config" or "Download Config File" instead.</p>'; showToast('Content too large for QR - use copy/download.', 'warning'); return; } const img = new Image(); img.src = googleChartsUrl; img.alt = 'QR Code'; img.style.maxWidth = '100%'; img.style.height = 'auto'; img.style.border = '2px solid #fff'; img.style.borderRadius = '8px'; img.onload = function() { qrDisplay.appendChild(img); try { const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); generatedImage = canvas.toDataURL('image/png'); } catch (e) { console.warn("Could not get data URL from Google Charts image for download due to security/cross-origin. Falling back to image src.", e); generatedImage = img.src; } showToast('‚úì QR Code Generated (Cloud Fallback)', 'success'); }; img.onerror = function() { qrDisplay.innerHTML = '<p style="color:var(--danger)">‚ùå All QR generation methods failed. Please copy the configuration manually.</p>'; showToast('QR generation failed - copy manually.', 'error'); }; } catch (googleErr) { console.error('Final QR generation fallback (Google Charts) failed:', googleErr); qrDisplay.innerHTML = '<p style="color:var(--danger)">‚ùå All QR methods failed. Please copy configuration manually.</p>'; showToast('QR generation failed.', 'error'); } } if (generatedImage) { qrDownloadImageLink.href = generatedImage; qrDownloadImageLink.classList.remove('hidden'); } else { qrDownloadImageLink.classList.add('hidden'); } if (text) { const blob = new Blob([text], { type: 'text/plain;charset=utf-8' }); qrDirectLink.href = URL.createObjectURL(blob); qrDirectLink.classList.remove('hidden'); const configName = text.startsWith('vless://') ? 'vless_config.txt' : text.startsWith('vmess://') ? 'vmess_config.txt' : text.startsWith('ss://') ? 'shadowsocks_config.txt' : text.startsWith('trojan://') ? 'trojan_config.txt' : 'config.txt'; qrDirectLink.download = configName; } else { qrDirectLink.classList.add('hidden'); } }, 100); } async function copyToClipboard(text, button) { try { await navigator.clipboard.writeText(text); const originalText = button.innerHTML; button.innerHTML = '‚úì Copied!'; if (button) button.disabled = true; setTimeout(() => { if (button) { button.innerHTML = originalText; button.disabled = false; } }, 2000); showToast('‚úì Copied to clipboard!', 'success'); } catch (error) { try { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.top = "0"; textArea.style.left = "0"; textArea.style.opacity = "0"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); document.execCommand('copy'); document.body.removeChild(textArea); const originalText = button.innerHTML; button.innerHTML = '‚úì Copied!'; if (button) button.disabled = true; setTimeout(() => { if (button) { button.innerHTML = originalText; button.disabled = false; } }, 2000); showToast('‚úì Copied to clipboard (fallback)!', 'success'); } catch(err) { showToast('Failed to copy. Please copy manually.', 'error'); console.error('Copy error:', error, err); } } } function downloadConfig(content, filename) { const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); showToast(`‚úì Configuration downloaded: ${filename}`, 'success'); } function handleDataAction(e) { const btn = e.target.closest('[data-action]'); if (!btn) return; const action = btn.dataset.action; if (!action) return; e.preventDefault(); e.stopPropagation(); switch (action) { case 'refresh': location.reload(); break; case 'copy-sub': { const urlType = btn.dataset.urlType; const url = urlType === 'xray' ? window.CONFIG.subXrayUrl : window.CONFIG.subSbUrl; if (url) copyToClipboard(url, btn); break; } case 'copy-config': { const configType = btn.dataset.configType; const config = configType === 'xray' ? window.CONFIG.singleXrayConfig : window.CONFIG.singleSingboxConfig; if (config) copyToClipboard(config, btn); break; } case 'open-qr-modal': { const configType = btn.dataset.configType; let text; if (configType === 'xray') { text = window.CONFIG.singleXrayConfig; } else if (configType === 'singbox') { text = window.CONFIG.singleSingboxConfig; } if (text) generateQRCode(text); break; } case 'close-modal': { document.getElementById('qrModal')?.classList.remove('show'); break; } case 'toggle-config-view': { const targetId = btn.dataset.target; const target = document.getElementById(targetId); if (target) { target.classList.toggle('hidden'); btn.textContent = target.classList.contains('hidden') ? 'View Config' : 'Hide Config'; } break; } case 'download-config': { const type = btn.dataset.type; if (type === 'xray') { downloadConfig(window.CONFIG.singleXrayConfig, 'xray-config.txt'); } else if (type === 'singbox') { downloadConfig(window.CONFIG.singleSingboxConfig, 'singbox-config.txt'); } break; } case 'direct-import': { const clientType = btn.dataset.client; let importUrl = '#'; const subUrl = window.CONFIG.subXrayUrl; const sbSubUrl = window.CONFIG.subSbUrl; switch(clientType) { case 'v2rayng': importUrl = `v2rayng://install-config?url=${encodeURIComponent(subUrl)}`; break; case 'shadowrocket': importUrl = `shadowrocket://add/sub?url=${encodeURIComponent(subUrl)}&name=${encodeURIComponent(window.CONFIG.host)}`; break; case 'streisand': importUrl = `streisand://install-config?url=${encodeURIComponent(subUrl)}`; break; case 'karing': importUrl = `karing://install-config?url=${encodeURIComponent(subUrl)}`; break; case 'clashMeta': importUrl = `clash://install-config?url=${encodeURIComponent(sbSubUrl)}`; break; case 'exclave': importUrl = `sn://subscription?url=${encodeURIComponent(sbSubUrl)}&name=${encodeURIComponent(window.CONFIG.host)}`; break; default: showToast(`Unsupported client: ${clientType}`, 'warning'); return; } if (importUrl !== '#') { window.location.href = importUrl; showToast(`Attempting to open ${clientType}... Please confirm in your app.`, 'info', 5000); } break; } } } function updateExpirationDisplay() { const countdownEl = document.getElementById('expiry-countdown'); const statusBadgeEl = document.getElementById('status-badge'); const expiryLocalEl = document.getElementById('expiry-local'); const expiryUtcEl = document.getElementById('expiry-utc'); const expiryStatusMessageEl = document.getElementById('expiry-status-message'); const expirationCard = document.getElementById('expiration-card'); if (!countdownEl || !statusBadgeEl || !expiryLocalEl || !expiryUtcEl || !expiryStatusMessageEl || !expirationCard) return; if (!window.CONFIG.expirationDateTime || window.CONFIG.expirationDateTime === "null" || window.CONFIG.expirationDateTime === "undefined") { countdownEl.textContent = 'Unlimited'; statusBadgeEl.textContent = 'Active'; statusBadgeEl.parentElement.className = 'stat status-active'; expiryLocalEl.textContent = 'No expiration set'; expiryUtcEl.textContent = ''; expiryStatusMessageEl.className = 'expiry-info'; expiryStatusMessageEl.innerHTML = '‚úì Your account has no expiration date.'; expirationCard.classList.remove('hidden'); return; } else { expirationCard.classList.remove('hidden'); } const expiryDate = new Date(window.CONFIG.expirationDateTime); if (isNaN(expiryDate.getTime())) { countdownEl.textContent = 'Invalid'; statusBadgeEl.textContent = 'Error'; statusBadgeEl.parentElement.className = 'stat status-expired'; expiryLocalEl.textContent = 'Invalid date/time'; expiryUtcEl.textContent = ''; expiryStatusMessageEl.className = 'expiry-warning'; expiryStatusMessageEl.innerHTML = '‚ö†Ô∏è Invalid expiration date/time found. Please contact support.'; return; } const now = new Date(); const diffMs = expiryDate - now; const diffSeconds = Math.floor(diffMs / 1000); if (diffSeconds < 0) { countdownEl.textContent = 'Expired'; statusBadgeEl.textContent = 'Expired'; statusBadgeEl.parentElement.className = 'stat status-expired'; expiryStatusMessageEl.className = 'expiry-warning'; expiryStatusMessageEl.innerHTML = '‚ö†Ô∏è Your account has expired. Please contact admin to renew.'; } else { statusBadgeEl.textContent = 'Active'; statusBadgeEl.parentElement.className = 'stat status-active'; expiryStatusMessageEl.className = 'expiry-info'; expiryStatusMessageEl.innerHTML = '‚úì Your account is active and working normally.'; const days = Math.floor(diffSeconds / 86400); const hours = Math.floor((diffSeconds % 86400) / 3600); const minutes = Math.floor((diffSeconds % 3600) / 60); const seconds = diffSeconds % 60; let display = ''; if (days > 0) { display = `${days}d ${hours}h`; } else if (hours > 0) { display = `${hours}h ${minutes}m`; } else if (minutes > 0) { display = `${minutes}m ${seconds}s`; } else { display = `${seconds}s`; } countdownEl.textContent = display; } expiryLocalEl.textContent = `Expires: ${expiryDate.toLocaleString()}`; expiryUtcEl.textContent = `UTC: ${expiryDate.toISOString().replace('T', ' ').substring(0, 19)}`; } function animateProgressBar(targetWidth) { const progressBar = document.getElementById('progress-bar-fill'); if (progressBar) { setTimeout(() => { progressBar.style.width = `${targetWidth}%`; }, 100); } } async function updateTrafficUsage(trafficUsedBytes) { const usageDisplayEl = document.getElementById('usage-display'); const totalDownStatEl = document.getElementById('total-down-stat'); const analyticsTotalDownloadEl = document.getElementById('analytics-total-download'); const usagePercentageEl = document.getElementById('usage-percentage'); const progressBarFill = document.getElementById('progress-bar-fill'); const usageTextEl = document.getElementById('usage-text'); const usageStatsCard = document.getElementById('usage-stats-card'); const dataLimitDisplayEl = document.getElementById('data-limit-display'); const trafficUsedFormatted = await formatBytes(trafficUsedBytes); if (usageDisplayEl) usageDisplayEl.textContent = trafficUsedFormatted; if (totalDownStatEl) totalDownStatEl.textContent = trafficUsedFormatted; if (analyticsTotalDownloadEl) analyticsTotalDownloadEl.textContent = trafficUsedFormatted; if (window.CONFIG.trafficLimit && window.CONFIG.trafficLimit > 0) { usageStatsCard.classList.remove('hidden'); const usagePercentage = Math.min(((trafficUsedBytes / window.CONFIG.trafficLimit) * 100), 100); const trafficLimitFormatted = await formatBytes(window.CONFIG.trafficLimit); if (dataLimitDisplayEl) dataLimitDisplayEl.textContent = trafficLimitFormatted; if (usagePercentageEl) usagePercentageEl.textContent = `${usagePercentage.toFixed(2)}% Used`; if (progressBarFill) { progressBarFill.dataset.targetWidth = usagePercentage.toFixed(2); progressBarFill.className = `progress-fill ${usagePercentage > 80 ? 'high' : usagePercentage > 50 ? 'medium' : 'low'}`; animateProgressBar(usagePercentage); } if (usageTextEl) usageTextEl.textContent = `${trafficUsedFormatted} of ${trafficLimitFormatted} used`; const dataLimitStatCard = document.querySelector('.stats .stat:nth-child(3)'); if (dataLimitStatCard) { if (usagePercentage > 80) { dataLimitStatCard.classList.add('status-warning'); dataLimitStatCard.querySelector('.val').style.color = 'var(--warning)'; } else { dataLimitStatCard.classList.remove('status-warning'); dataLimitStatCard.querySelector('.val').style.color = 'var(--text-primary)'; } } } else { usageStatsCard.classList.add('hidden'); if (dataLimitDisplayEl) dataLimitDisplayEl.textContent = 'Unlimited'; document.querySelector('.stats .stat:nth-child(3)').classList.remove('status-warning'); } } (function() { const RASPS_CONFIG = { ENDPOINT: `/api/user/${window.CONFIG.uuid}`, POLL_MIN_MS: 10000, POLL_MAX_MS: 30000, INACTIVE_MULTIPLIER: 6, MAX_BACKOFF_MS: 600000, INITIAL_BACKOFF_MS: 2000, BACKOFF_FACTOR: 1.8, }; let lastDataHash = null; let currentBackoff = RASPS_CONFIG.INITIAL_BACKOFF_MS; let isPolling = false; let pollTimeout = null; let isPageVisible = document.visibilityState === 'visible'; function getRandomDelay() { const baseMin = RASPS_CONFIG.POLL_MIN_MS; const baseMax = RASPS_CONFIG.POLL_MAX_MS; const multiplier = isPageVisible ? 1 : RASPS_CONFIG.INACTIVE_MULTIPLIER; return Math.floor(Math.random() * ((baseMax - baseMin) * multiplier + 1)) + baseMin * multiplier; } function computeHash(data) { const relevantData = { traffic_used: data.traffic_used, expiration_date: data.expiration_date, expiration_time: data.expiration_time, is_expired: data.is_expired }; const str = JSON.stringify(relevantData); let hash = 0; for (let i = 0; i < str.length; i++) { const char = str.charCodeAt(i); hash = ((hash << 5) - hash) + char; hash = hash & hash; } return hash.toString(36); } async function updateDOM(data) { if (data.traffic_used !== undefined) { await updateTrafficUsage(data.traffic_used); window.CONFIG.initialTrafficUsed = data.traffic_used; } if (data.expiration_date && data.expiration_time) { window.CONFIG.expirationDateTime = `${data.expiration_date}T${data.expiration_time}Z`; window.CONFIG.isExpired = data.is_expired; updateExpirationDisplay(); } } async function fetchData() { try { const response = await fetch(RASPS_CONFIG.ENDPOINT, { method: 'GET', headers: { 'Cache-Control': 'no-cache' }, cache: 'no-store' }); if (response.status === 304) { return null; } if (!response.ok) { if ([404, 403].includes(response.status)) { showToast(`Error: ${response.status} - User data access denied. Please contact admin.`, 'error', 5000); throw new Error(`Critical API error: ${response.status}`); } throw new Error(`HTTP error: ${response.status}`); } const data = await response.json(); const newHash = computeHash(data); if (newHash === lastDataHash) { return null; } lastDataHash = newHash; return data; } catch (error) { console.warn('RASPS fetch error:', error.message); throw error; } } function scheduleNextPoll() { if (pollTimeout) clearTimeout(pollTimeout); const delay = getRandomDelay(); pollTimeout = setTimeout(poll, delay); } async function poll() { if (!isPolling) return; try { const data = await fetchData(); if (data) { await updateDOM(data); } currentBackoff = RASPS_CONFIG.INITIAL_BACKOFF_MS; } catch (error) { currentBackoff = Math.min(currentBackoff * RASPS_CONFIG.BACKOFF_FACTOR, RASPS_CONFIG.MAX_BACKOFF_MS); console.error(`RASPS: Poll failed, backing off. Next attempt in ${Math.round(currentBackoff / 1000)}s.`); } finally { scheduleNextPoll(); } } function handleVisibilityChange() { isPageVisible = document.visibilityState === 'visible'; if (isPageVisible) { currentBackoff = RASPS_CONFIG.INITIAL_BACKOFF_MS; if (pollTimeout) clearTimeout(pollTimeout); poll(); } } function startPolling() { if (isPolling) return; isPolling = true; document.addEventListener('visibilitychange', handleVisibilityChange); poll(); } if (window.CONFIG.uuid && RASPS_CONFIG.ENDPOINT) { startPolling(); } else { console.warn('RASPS: Missing UUID or API endpoint, polling disabled.'); } })(); document.addEventListener('DOMContentLoaded', () => { document.getElementById('account-uuid').textContent = window.CONFIG.uuid; document.getElementById('info-proxy-host').textContent = window.CONFIG.proxyAddress.split(':')[0]; document.getElementById('info-proxy-ip').textContent = window.CONFIG.proxyGeo.ip || 'Resolving...'; document.getElementById('info-proxy-location').textContent = [window.CONFIG.proxyGeo.city, window.CONFIG.proxyGeo.country].filter(Boolean).join(', ') || 'Unknown'; document.getElementById('info-client-ip').textContent = window.CONFIG.clientIp; document.getElementById('info-client-location').textContent = [window.CONFIG.clientGeo.city, window.CONFIG.clientGeo.country].filter(Boolean).join(', ') || 'Unknown'; document.getElementById('info-client-isp').textContent = window.CONFIG.clientGeo.isp || 'Unknown'; document.getElementById('xray-config-view').textContent = window.CONFIG.singleXrayConfig; document.getElementById('sb-config-view').textContent = window.CONFIG.singleSingboxConfig; const accountNotesContainer = document.getElementById('account-notes-container'); const accountNotesEl = document.getElementById('account-notes'); if (window.CONFIG.notes && window.CONFIG.notes !== "null") { accountNotesEl.textContent = window.CONFIG.notes; accountNotesContainer.classList.remove('hidden'); } else { accountNotesContainer.classList.add('hidden'); } document.getElementById('account-ip-limit').textContent = window.CONFIG.ipLimit === -1 ? 'Unlimited' : window.CONFIG.ipLimit; updateExpirationDisplay(); updateTrafficUsage(window.CONFIG.initialTrafficUsed); setInterval(updateUptime, 60000); setInterval(simulateLiveStats, 3000); setInterval(updateUploadStats, 30000); updateUptime(); simulateLiveStats(); updateUploadStats(); document.addEventListener('click', handleDataAction, false); document.addEventListener('touchend', handleDataAction, false); document.querySelectorAll('.analytics-tab').forEach(tabBtn => { tabBtn.addEventListener('click', () => { switchTab(tabBtn, tabBtn.dataset.tab); if (tabBtn.dataset.tab === 'history') { updateConnectionHistory(); } else if (tabBtn.dataset.tab === 'analytics') { updateAnalyticsStats(); } }); }); async function updateAnalyticsStats() { const analyticsAvgLatencyEl = document.getElementById('analytics-avg-latency'); const analyticsConnectionsEl = document.getElementById('analytics-connections'); if (analyticsAvgLatencyEl) analyticsAvgLatencyEl.textContent = `${Math.floor(Math.random() * 20 + 35)}ms`; if (analyticsConnectionsEl) analyticsConnectionsEl.textContent = `${Math.floor(Math.random() * 5 + 1)}`; } async function updateConnectionHistory() { const historyContent = document.getElementById('history-content'); if (!historyContent || historyContent.classList.contains('hidden')) return; historyContent.innerHTML = `<div style="text-align:center;padding:20px;color:var(--muted)"> <div class="loading-spinner"></div> <p>Loading connection history...</p> <p style="font-size:13px;margin-top:8px;opacity:0.7">Fetching recent session data and activity logs.</p> </div>`; try { const response = await fetch(`/api/user/${window.CONFIG.uuid}/history`); if (!response.ok) throw new Error('Failed to fetch history'); const data = await response.json(); const historyData = data.history || []; if (historyData.length === 0) { historyContent.innerHTML = `<div style="text-align:center;padding:20px;color:var(--muted)"><p>No connection history available yet.</p></div>`; return; } const historyHTML = `<div style="padding:10px 0"> <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:10px;background:rgba(59,130,246,0.1);border-radius:8px;margin-bottom:12px;font-size:11px;text-transform:uppercase;color:var(--muted);font-weight:600"> <span>Date</span><span>Download</span><span>Upload</span><span>Sessions</span> </div> ${historyData.map(s => ` <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:12px 10px;border-bottom:1px solid rgba(255,255,255,0.05);font-size:13px"> <span style="color:var(--muted)">${new Date(s.date).toLocaleDateString()}</span> <span style="color:var(--accent)">${formatBytes(s.download)}</span> <span style="color:var(--success)">${formatBytes(s.upload)}</span> <span style="color:var(--purple)">${s.sessions}</span> </div> `).join('')} </div>`; historyContent.innerHTML = historyHTML; } catch (e) { console.error('Failed to load connection history:', e); historyContent.innerHTML = `<div style="text-align:center;padding:20px;color:var(--danger)"><p>Error loading history. Please try again later.</p></div>`; } } updateAnalyticsStats(); setInterval(() => { const historyTabButton = document.querySelector('.analytics-tab[data-tab="history"]'); if (historyTabButton && historyTabButton.classList.contains('active')) { updateConnectionHistory(); } }, 60000); }); </script> </body> </html>`;
D1 Persistence Logic, API Endpoints, & Final Integration // ============================================================================ // D1 DATABASE INTEGRATION AND MANAGEMENT - Quantum Persistence Layer // Functions for schema management, proxy health monitoring, and data cleanup. // This ensures reliable data storage and dynamic proxy selection. // ============================================================================ async function ensureTablesExist(env, ctx) { if (!env.DB) { console.warn('D1 binding not available. Skipping table creation.'); return; } try { const createTables = [ `CREATE TABLE IF NOT EXISTS users ( uuid TEXT PRIMARY KEY, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, expiration_date TEXT NOT NULL, expiration_time TEXT NOT NULL, notes TEXT, traffic_limit INTEGER, traffic_used INTEGER DEFAULT 0, ip_limit INTEGER DEFAULT -1 )`, `CREATE TABLE IF NOT EXISTS user_ips ( uuid TEXT, ip TEXT, last_seen DATETIME DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (uuid, ip), FOREIGN KEY (uuid) REFERENCES users(uuid) ON DELETE CASCADE )`, `CREATE TABLE IF NOT EXISTS key_value ( key TEXT PRIMARY_KEY, value TEXT NOT_NULL, expiration INTEGER )`, `CREATE TABLE IF NOT EXISTS proxy_health ( ip_port TEXT PRIMARY KEY, is_healthy INTEGER NOT NULL, latency_ms INTEGER, last_check INTEGER DEFAULT (strftime('%s', 'now')) )`, `CREATE TABLE IF NOT EXISTS security_events ( id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp INTEGER NOT NULL, ip TEXT NOT NULL, type TEXT NOT NULL, details TEXT, uuid TEXT )`, `CREATE TABLE IF NOT EXISTS ip_blacklist ( ip TEXT PRIMARY KEY, expiration INTEGER NOT NULL, reason TEXT, timestamp INTEGER NOT NULL DEFAULT (strftime('%s', 'now')) )` ]; const stmts = createTables.map(sql => env.DB.prepare(sql)); await env.DB.batch(stmts); const testUUID = env.UUID || Config.userID; const futureDate = new Date(); futureDate.setMonth(futureDate.getMonth() + 1); const expDate = futureDate.toISOString().split('T')[0]; const expTime = '23:59:59'; const insertTestUser = env.DB.prepare( "INSERT OR IGNORE INTO users (uuid, expiration_date, expiration_time, notes, traffic_limit, traffic_used, ip_limit) VALUES (?, ?, ?, ?, ?, ?, ?)" ).bind(testUUID, expDate, expTime, 'Test User - Development', null, 1073741824, -1); await insertTestUser.run(); console.log('D1 tables initialized successfully and test user ensured.'); } catch (e) { console.error(e.message, e.stack); throw new Error('Database initialization failed. Critical error: ' + e.message); } } async function performHealthCheck(env, ctx) { if (!env.DB) { console.warn('D1 binding not available. Skipping health checks.'); return; } const proxyIps = env.PROXYIPS ? env.PROXYIPS.split(',').map(ip => ip.trim()) : Config.proxyIPs; const healthStmts = []; const results = await Promise.allSettled(proxyIps.map(async (ipPort) => { const [host, port = '443'] = ipPort.split(':'); let latency = null; let isHealthy = 0; const start = Date.now(); try { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), CONST.HEALTH_CHECK_TIMEOUT); const response = await fetch(`https://${host}:${port}`, { method: 'HEAD', signal: controller.signal, redirect: 'manual', }); clearTimeout(timeoutId); if (response.ok || (response.status >= 400 && response.status < 500)) { latency = Date.now() - start; isHealthy = 1; } else { console.warn(`Health check for ${ipPort} failed: HTTP Status ${response.status}.`); } } catch (e) { if (e.name === 'AbortError') { console.error(`Health check for ${ipPort} timed out after ${CONST.HEALTH_CHECK_TIMEOUT}ms.`); } else { console.error(`Health check failed for ${ipPort}: ${e.message}.`); } } finally { healthStmts.push( env.DB.prepare( "INSERT OR REPLACE INTO proxy_health (ip_port, is_healthy, latency_ms, last_check) VALUES (?, ?, ?, ?)" ).bind(ipPort, isHealthy, latency, Math.floor(Date.now() / 1000)) ); } })); results.filter(r => r.status === 'rejected').forEach(r => console.error(r.reason)); try { await env.DB.batch(healthStmts); console.log('Proxy health check and database update completed.'); } catch (e) { console.error(e.message, e.stack); throw new Error('Failed to batch update proxy health status in D1: ' + e.message); } } async function cleanupOldIps(env, ctx) { if (!env.DB) { console.warn('D1 binding not available. Skipping data cleanup.'); return; } try { const cleanupPromises = []; cleanupPromises.push(env.DB.prepare( "DELETE FROM user_ips WHERE last_seen < datetime('now', ?)" ).bind(`-${CONST.IP_CLEANUP_AGE_DAYS} days`).run()); cleanupPromises.push(env.DB.prepare( "DELETE FROM ip_blacklist WHERE expiration <= ?" ).bind(Math.floor(Date.now() / 1000)).run()); cleanupPromises.push(env.DB.prepare( "DELETE FROM key_value WHERE expiration <= ?" ).bind(Math.floor(Date.now() / 1000)).run()); await Promise.all(cleanupPromises.map(p => p.catch(e => console.error(e.message)))); console.log(`Cleaned up user_ips records older than ${CONST.IP_CLEANUP_AGE_DAYS} days and expired blacklist/key_value entries.`); } catch (e) { console.error(e.message, e.stack); throw new Error('Failed to perform scheduled database cleanup: ' + e.message); } } async function handleAdminRequest(request, env, ctx, adminPrefix) { try { await ensureTablesExist(env, ctx); const url = new URL(request.url); const jsonHeader = { 'Content-Type': 'application/json' }; const htmlHeaders = new Headers({ 'Content-Type': 'text/html;charset=utf-8' }); const clientIp = request.headers.get('CF-Connecting-IP'); if (!env.ADMIN_KEY) { addSecurityHeaders(htmlHeaders, null, {}); return new Response('Admin panel not configured: ADMIN_KEY is missing.', { status: 503, headers: htmlHeaders }); } const isBlocked = await checkBlockedIP(env.DB, clientIp); if (isBlocked) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_ACCESS_DENIED', `Attempted admin panel access from blacklisted IP: ${clientIp}.`)); addSecurityHeaders(htmlHeaders, null, {}); return new Response('Access Denied: Your IP address is currently blocked due to suspicious activity. Please contact support.', { status: 403, headers: htmlHeaders }); } if (env.ADMIN_IP_WHITELIST) { const allowedIps = env.ADMIN_IP_WHITELIST.split(',').map(ip => ip.trim()); if (!allowedIps.includes(clientIp)) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_ACCESS_DENIED', `IP not in ADMIN_IP_WHITELIST. IP: ${clientIp}.`)); addSecurityHeaders(htmlHeaders, null, {}); return new Response('Access denied: Your IP is not authorized.', { status: 403, headers: htmlHeaders }); } } else { const scamalyticsConfig = { username: env.SCAMALYTICS_USERNAME || Config.scamalytics.username, apiKey: env.SCAMALYTICS_API_KEY || Config.scamalytics.apiKey, baseUrl: env.SCAMALYTICS_BASEURL || Config.scamalytics.baseUrl, }; if (scamalyticsConfig.username && scamalyticsConfig.apiKey) { if (await isSuspiciousIP(clientIp, scamalyticsConfig, env.SCAMALYTICS_THRESHOLD || CONST.SCAMALYTICS_THRESHOLD)) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_ACCESS_DENIED', `Scamalytics score too high. IP: ${clientIp}.`)); ctx.waitUntil(addIpToBlacklist(env.DB, ctx, clientIp, 'Scamalytics High Score', CONST.IP_BLACKLIST_TTL)); addSecurityHeaders(htmlHeaders, null, {}); return new Response('Access denied: Your IP has been flagged as suspicious.', { status: 403, headers: htmlHeaders }); } } } if (env.ADMIN_HEADER_KEY) { const headerValue = request.headers.get('X-Admin-Auth'); if (!timingSafeEqual(headerValue || '', env.ADMIN_HEADER_KEY)) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_ACCESS_DENIED', `Invalid custom auth header. IP: ${clientIp}.`)); addSecurityHeaders(htmlHeaders, null, {}); return new Response('Access denied: Invalid authentication header.', { status: 403, headers: htmlHeaders }); } } const adminBasePath = `/${adminPrefix}/${env.ADMIN_KEY}`; if (!url.pathname.startsWith(adminBasePath)) { const headers = new Headers(); addSecurityHeaders(headers, null, {}); return new Response('Not Found', { status: 404, headers }); } const adminSubPath = url.pathname.substring(adminBasePath.length) || '/'; if (adminSubPath.startsWith('/api/')) { if (!env.DB) { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); return new Response(JSON.stringify({ error: 'Database not configured for API operations.' }), { status: 503, headers }); } if (!(await isAdmin(request, env))) { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); return new Response(JSON.stringify({ error: 'Unauthorized: Admin session expired or not logged in.' }), { status: 401, headers }); } const apiRateKey = `admin_api_rate:${clientIp}`; if (await checkRateLimit(env.DB, apiRateKey, 100, 60)) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_API_RATE_LIMIT', `API rate limit exceeded. IP: ${clientIp}.`)); const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); return new Response(JSON.stringify({ error: 'API rate limit exceeded. Please try again later.' }), { status: 429, headers }); } if (request.method !== 'GET') { const origin = request.headers.get('Origin'); const secFetchSite = request.headers.get('Sec-Fetch-Site'); const currentHost = url.hostname; if (!origin || new URL(origin).hostname !== currentHost || secFetchSite !== 'same-origin') { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'CSRF_ATTEMPT', `Invalid request origin or Sec-Fetch-Site header. IP: ${clientIp}.`)); const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); return new Response(JSON.stringify({ error: 'Invalid request origin or Sec-Fetch-Site header (CSRF defense).' }), { status: 403, headers }); } const csrfToken = request.headers.get('X-CSRF-Token'); const cookieCsrfMatch = request.headers.get('Cookie')?.match(/csrf_token=([^;]+)/); const cookieCsrf = cookieCsrfMatch ? cookieCsrfMatch[1] : null; if (!csrfToken || !cookieCsrf || !timingSafeEqual(csrfToken, cookieCsrf)) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'CSRF_ATTEMPT', `Invalid or missing CSRF token. IP: ${clientIp}.`)); const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); return new Response(JSON.stringify({ error: 'CSRF validation failed: Invalid or missing CSRF token.' }), { status: 403, headers }); } } if (adminSubPath === '/api/stats' && request.method === 'GET') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const totalUsers = await env.DB.prepare("SELECT COUNT(*) as count FROM users").first('count'); const expiredQuery = await env.DB.prepare( "SELECT COUNT(*) as count FROM users WHERE datetime(expiration_date || 'T' || expiration_time || 'Z') < datetime('now')" ).first(); const expiredUsers = expiredQuery?.count || 0; const activeUsers = totalUsers - expiredUsers; const totalTrafficQuery = await env.DB.prepare("SELECT SUM(traffic_used) as sum FROM users").first(); const totalTraffic = totalTrafficQuery?.sum || 0; const blockedIPsCount = await env.DB.prepare("SELECT COUNT(*) as count FROM ip_blacklist WHERE expiration > ?").bind(Math.floor(Date.now() / 1000)).first('count'); let proxyHealth = { is_healthy: 0, latency_ms: null }; try { const healthResult = await env.DB.prepare( "SELECT is_healthy, latency_ms FROM proxy_health ORDER BY is_healthy DESC, latency_ms ASC LIMIT 1" ).first(); if (healthResult) { proxyHealth = { is_healthy: !!healthResult.is_healthy, latency_ms: healthResult.latency_ms }; } } catch (healthErr) { console.error(healthErr.message); } return new Response(JSON.stringify({ total_users: totalUsers, active_users: activeUsers, expired_users: expiredUsers, total_traffic: totalTraffic, proxy_health: proxyHealth, blocked_ips_count: blockedIPsCount }), { status: 200, headers }); } catch (e) { return new Response(JSON.stringify({ error: `Failed to fetch stats: ${e.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/users' && request.method === 'GET') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const { results } = await env.DB.prepare( "SELECT uuid, created_at, expiration_date, expiration_time, notes, traffic_limit, traffic_used, ip_limit FROM users ORDER BY created_at DESC" ).all(); return new Response(JSON.stringify(results ?? []), { status: 200, headers }); } catch (e) { return new Response(JSON.stringify({ error: `Failed to fetch users: ${e.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/users' && request.method === 'POST') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const { uuid, exp_date: expDate, exp_time: expTime, notes, traffic_limit, ip_limit } = await request.json(); if (!uuid || !expDate || !expTime || !isValidUUID(uuid) || !/^\d{4}-\d{2}-\d{2}$/.test(expDate) || !/^\d{2}:\d{2}:\d{2}$/.test(expTime)) { throw new Error('Invalid or missing UUID, expiration date, or expiration time format.'); } await env.DB.prepare( "INSERT INTO users (uuid, expiration_date, expiration_time, notes, traffic_limit, ip_limit, traffic_used) VALUES (?, ?, ?, ?, ?, ?, 0)" ).bind(uuid, expDate, expTime, notes || null, traffic_limit, ip_limit || -1).run(); ctx.waitUntil(d1KvDelete(env.DB, `user:${uuid}`)); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'USER_CREATED', `User ${uuid} created by admin.`, uuid)); return new Response(JSON.stringify({ success: true, uuid }), { status: 201, headers }); } catch (error) { if (error.message?.includes('UNIQUE constraint failed')) { return new Response(JSON.stringify({ error: 'User with this UUID already exists.' }), { status: 409, headers }); } return new Response(JSON.stringify({ error: `Failed to create user: ${error.message}` }), { status: 400, headers }); } } if (adminSubPath === '/api/users/bulk-delete' && request.method === 'POST') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const { uuids } = await request.json(); if (!Array.isArray(uuids) || uuids.length === 0) { throw new Error('Invalid request: Expected an array of UUIDs.'); } const deleteUserStmt = env.DB.prepare("DELETE FROM users WHERE uuid = ?"); const stmts = uuids.map(uuid => deleteUserStmt.bind(uuid)); await env.DB.batch(stmts); ctx.waitUntil(Promise.all(uuids.map(uuid => d1KvDelete(env.DB, `user:${uuid}`))) .catch(e => console.error(e.message))); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'USER_BULK_DELETED', `Bulk deleted ${uuids.length} users by admin.`, null)); return new Response(JSON.stringify({ success: true, count: uuids.length }), { status: 200, headers }); } catch (error) { return new Response(JSON.stringify({ error: `Failed to bulk delete users: ${error.message}` }), { status: 400, headers }); } } const userRouteMatch = adminSubPath.match(/^\/api\/users\/([a-f0-9-]+)$/i); if (userRouteMatch && request.method === 'PUT') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); const uuid = userRouteMatch[1]; try { const { exp_date: expDate, exp_time: expTime, notes, traffic_limit, ip_limit, reset_traffic } = await request.json(); if (!expDate || !expTime || !/^\d{4}-\d{2}-\d{2}$/.test(expDate) || !/^\d{2}:\d{2}:\d{2}$/.test(expTime)) { throw new Error('Invalid expiration date or time format.'); } if (!isValidUUID(uuid)) { throw new Error('Invalid UUID for update operation.'); } let query = "UPDATE users SET expiration_date = ?, expiration_time = ?, notes = ?, traffic_limit = ?, ip_limit = ?"; let binds = [expDate, expTime, notes || null, traffic_limit, ip_limit || -1]; if (reset_traffic) { query += ", traffic_used = 0"; } query += " WHERE uuid = ?"; binds.push(uuid); const { changes } = await env.DB.prepare(query).bind(...binds).run(); if (changes === 0) { return new Response(JSON.stringify({ success: false, message: 'User not found or no changes made.' }), { status: 404, headers }); } ctx.waitUntil(d1KvDelete(env.DB, `user:${uuid}`)); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'USER_UPDATED', `User ${uuid} updated by admin (reset_traffic: ${reset_traffic}).`, uuid)); return new Response(JSON.stringify({ success: true, uuid }), { status: 200, headers }); } catch (error) { return new Response(JSON.stringify({ error: `Failed to update user: ${error.message}` }), { status: 400, headers }); } } if (userRouteMatch && request.method === 'DELETE') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); const uuid = userRouteMatch[1]; if (!isValidUUID(uuid)) { return new Response(JSON.stringify({ error: 'Invalid UUID for delete operation.' }), { status: 400, headers }); } try { const { changes } = await env.DB.prepare("DELETE FROM users WHERE uuid = ?").bind(uuid).run(); if (changes === 0) { return new Response(JSON.stringify({ success: false, message: 'User not found.' }), { status: 404, headers }); } ctx.waitUntil(d1KvDelete(env.DB, `user:${uuid}`)); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'USER_DELETED', `User ${uuid} deleted by admin.`, uuid)); return new Response(JSON.stringify({ success: true, uuid }), { status: 200, headers }); } catch (error) { return new Response(JSON.stringify({ error: `Failed to delete user: ${error.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/logout' && request.method === 'POST') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { await d1KvDelete(env.DB, 'admin_session_token_hash'); const responseHeaders = new Headers(); responseHeaders.append('Set-Cookie', `auth_token=; Max-Age=0; Path=${adminBasePath}; Secure; HttpOnly; SameSite=Strict`); responseHeaders.append('Set-Cookie', `csrf_token=; Max-Age=0; Path=${adminBasePath}; Secure; SameSite=Strict`); addSecurityHeaders(responseHeaders, null, {}); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_LOGOUT', 'Admin logged out.')); return new Response(JSON.stringify({ success: true, message: 'Logged out successfully.' }), { status: 200, headers: responseHeaders }); } catch (error) { return new Response(JSON.stringify({ error: `Logout failed: ${error.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/health-check' && request.method === 'POST') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { await performHealthCheck(env, ctx); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'HEALTH_CHECK_TRIGGERED', 'Admin manually triggered proxy health check.')); return new Response(JSON.stringify({ success: true, message: 'Proxy health check initiated.' }), { status: 200, headers }); } catch (error) { return new Response(JSON.stringify({ error: `Health check failed to initiate: ${error.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/security/events' && request.method === 'GET') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const queryParams = new URL(request.url).searchParams; const eventType = queryParams.get('type') || ''; const timeFilter = queryParams.get('time') || ''; const searchTerm = queryParams.get('search') || ''; let whereClauses = []; let bindParams = []; if (eventType) { whereClauses.push("type = ?"); bindParams.push(eventType); } if (searchTerm) { whereClauses.push("(ip LIKE ? OR details LIKE ? OR uuid LIKE ?)"); bindParams.push(`%${searchTerm}%`, `%${searchTerm}%`, `%${searchTerm}%`); } let timeThreshold = 0; const now = Math.floor(Date.now() / 1000); if (timeFilter === '24h') timeThreshold = now - (24 * 3600); else if (timeFilter === '7d') timeThreshold = now - (7 * 24 * 3600); else if (timeFilter === '30d') timeThreshold = now - (30 * 24 * 3600); if (timeThreshold > 0) { whereClauses.push("timestamp >= ?"); bindParams.push(timeThreshold); } const whereSql = whereClauses.length > 0 ? " WHERE " + whereClauses.join(" AND ") : ""; const query = `SELECT * FROM security_events ${whereSql} ORDER BY timestamp DESC LIMIT 200`; const { results } = await env.DB.prepare(query).bind(...bindParams).all(); return new Response(JSON.stringify(results ?? []), { status: 200, headers }); } catch (e) { return new Response(JSON.stringify({ error: `Failed to fetch security events: ${e.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/security/blacklist' && request.method === 'GET') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const now = Math.floor(Date.now() / 1000); const queryParams = new URL(request.url).searchParams; const searchTerm = queryParams.get('search') || ''; let whereClauses = ["expiration > ?"]; let bindParams = [now]; if (searchTerm) { whereClauses.push("(ip LIKE ? OR reason LIKE ?)"); bindParams.push(`%${searchTerm}%`, `%${searchTerm}%`); } const whereSql = whereClauses.length > 0 ? " WHERE " + whereClauses.join(" AND ") : ""; const query = `SELECT ip, expiration, reason, timestamp FROM ip_blacklist ${whereSql} ORDER BY timestamp DESC`; const { results } = await env.DB.prepare(query).bind(...bindParams).all(); return new Response(JSON.stringify(results ?? []), { status: 200, headers }); } catch (e) { return new Response(JSON.stringify({ error: `Failed to fetch IP blacklist: ${e.message}` }), { status: 500, headers }); } } if (adminSubPath === '/api/security/blacklist' && request.method === 'POST') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); try { const { ip, reason, duration } = await request.json(); if (!ip || !reason) { throw new Error('IP address and reason are required for blacklisting.'); } const ttl = duration === 0 ? (365 * 24 * 3600 * 100) : duration; await addIpToBlacklist(env.DB, ctx, ip, reason, ttl); return new Response(JSON.stringify({ success: true, ip, reason, duration }), { status: 201, headers }); } catch (e) { return new Response(JSON.stringify({ error: `Failed to add IP to blacklist: ${e.message}` }), { status: 400, headers }); } } const blacklistRemoveMatch = adminSubPath.match(/^\/api\/security\/blacklist\/([^/]+)$/i); if (blacklistRemoveMatch && request.method === 'DELETE') { const headers = new Headers(jsonHeader); addSecurityHeaders(headers, null, {}); const ipToRemove = decodeURIComponent(blacklistRemoveMatch[1]); try { const { changes } = await env.DB.prepare("DELETE FROM ip_blacklist WHERE ip = ?").bind(ipToRemove).run(); if (changes === 0) { return new Response(JSON.stringify({ success: false, message: 'IP not found in blacklist.' }), { status: 404, headers }); } ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'IP_WHITELISTED', `IP ${ipToRemove} whitelisted by admin.`)); return new Response(JSON.stringify({ success: true, ip: ipToRemove, message: 'IP removed from blacklist.' }), { status: 200, headers }); } catch (e) { return new Response(JSON.stringify({ error: `Failed to remove IP from blacklist: ${e.message}` }), { status: 500, headers }); } } if (adminSubPath === '/') { if (request.method === 'POST') { const rateLimitKey = `admin_login_fail_ip:${clientIp}`; try { const failCountStr = await d1KvGet(env.DB, rateLimitKey); const failCount = parseInt(failCountStr, 10) || 0; if (failCount >= CONST.ADMIN_LOGIN_FAIL_LIMIT) { ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'BRUTE_FORCE_LOGIN', `Too many failed login attempts (${failCount + 1}). IP blacklisted. IP: ${clientIp}.`)); ctx.waitUntil(addIpToBlacklist(env.DB, ctx, clientIp, 'Brute-force login attempts', CONST.BRUTE_FORCE_LOGIN_TTL)); addSecurityHeaders(htmlHeaders, null, {}); return new Response('Too many failed attempts. Your IP has been temporarily blocked.', { status: 429, headers: htmlHeaders }); } const formData = await request.formData(); const passwordAttempt = formData.get('password'); const totpAttempt = formData.get('totp'); if (timingSafeEqual(passwordAttempt, env.ADMIN_KEY)) { if (env.ADMIN_TOTP_SECRET) { if (!(await validateTOTP(env.ADMIN_TOTP_SECRET, totpAttempt))) { const nonce = generateNonce(); addSecurityHeaders(htmlHeaders, nonce, {}); let html = adminLoginHTML.replace('action="ADMIN_PATH_PLACEHOLDER"', `action="${adminBasePath}"`); html = html.replace(/CSP_NONCE_PLACEHOLDER/g, nonce); html = html.replace('</form>', `</form><p class="error">Invalid 2FA code. Attempt ${failCount + 1}/${CONST.ADMIN_LOGIN_FAIL_LIMIT}.</p>`); ctx.waitUntil(d1KvPut(env.DB, rateLimitKey, (failCount + 1).toString(), { expirationTtl: CONST.ADMIN_LOGIN_LOCK_TTL })); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'BRUTE_FORCE_LOGIN', `Invalid 2FA code. IP: ${clientIp}.`)); return new Response(html, { status: 401, headers: htmlHeaders }); } } const authToken = crypto.randomUUID(); const csrfToken = crypto.randomUUID(); const hashedAuthToken = await hashSHA256(authToken); ctx.waitUntil(Promise.all([ d1KvPut(env.DB, 'admin_session_token_hash', hashedAuthToken, { expirationTtl: CONST.ADMIN_SESSION_TTL }), d1KvDelete(env.DB, rateLimitKey) ]).catch(e => console.error(e.message))); const responseHeaders = new Headers({ 'Location': adminBasePath }); responseHeaders.append('Set-Cookie', `auth_token=${authToken}; HttpOnly; Secure; Path=${adminBasePath}; Max-Age=${CONST.ADMIN_SESSION_TTL}; SameSite=Strict`); responseHeaders.append('Set-Cookie', `csrf_token=${csrfToken}; Secure; Path=${adminBasePath}; Max-Age=${CONST.ADMIN_SESSION_TTL}; SameSite=Strict`); addSecurityHeaders(responseHeaders, null, {}); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_LOGIN_SUCCESS', `Admin logged in successfully. IP: ${clientIp}.`)); return new Response(null, { status: 302, headers: responseHeaders }); } else { ctx.waitUntil(d1KvPut(env.DB, rateLimitKey, (failCount + 1).toString(), { expirationTtl: CONST.ADMIN_LOGIN_LOCK_TTL })); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'BRUTE_FORCE_LOGIN', `Invalid password attempt. IP: ${clientIp}.`)); const nonce = generateNonce(); addSecurityHeaders(htmlHeaders, nonce, {}); let html = adminLoginHTML.replace('action="ADMIN_PATH_PLACEHOLDER"', `action="${adminBasePath}"`); html = html.replace(/CSP_NONCE_PLACEHOLDER/g, nonce); html = html.replace('</form>', `</form><p class="error">Invalid password. Attempt ${failCount + 1}/${CONST.ADMIN_LOGIN_FAIL_LIMIT}.</p>`); return new Response(html, { status: 401, headers: htmlHeaders }); } } catch (e) { console.error(e.message, e.stack); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_LOGIN_ERROR', `Internal server error during login: ${e.message}. IP: ${clientIp}.`)); addSecurityHeaders(htmlHeaders, null, {}); return new Response('Internal server error during login. Please try again.', { status: 500, headers: htmlHeaders }); } } if (request.method === 'GET') { const nonce = generateNonce(); addSecurityHeaders(htmlHeaders, nonce, {}); let htmlContent; if (await isAdmin(request, env)) { htmlContent = adminPanelHTML; htmlContent = htmlContent.replace('ADMIN_API_BASE_PATH_PLACEHOLDER', adminBasePath + '/api'); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'ADMIN_DASHBOARD_ACCESS', `Admin dashboard accessed. IP: ${clientIp}.`)); } else { htmlContent = adminLoginHTML; htmlContent = htmlContent.replace('ADMIN_PATH_PLACEHOLDER', adminBasePath); } htmlContent = htmlContent.replace(/CSP_NONCE_PLACEHOLDER/g, nonce); return new Response(htmlContent, { headers: htmlHeaders }); } const headers = new Headers(); addSecurityHeaders(headers, null, {}); return new Response('Method Not Allowed', { status: 405, headers }); } const custom404Html = `<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>404 - Not Found</title> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet"> <style nonce="CSP_NONCE_PLACEHOLDER"> :root { --bg-main: #0a0e17; --text-primary: #F9FAFB; --text-secondary: #9CA3AF; --accent: #3B82F6; --border-light: rgba(255,255,255,0.06); --shadow-light: 0 8px 32px rgba(0,0,0,0.3); --radius-lg: 16px; } * { box-sizing: border-box; margin: 0; padding: 0; } body { font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; background: linear-gradient(135deg, #030712 0%, #0f172a 25%, #1e1b4b 50%, #0f172a 75%, #030712 100%); background-size: 400% 400%; animation: gradient-shift 15s ease infinite; color: var(--text-primary); min-height: 100vh; display: flex; justify-content: center; align-items: center; text-align: center; padding: 20px; position: relative; overflow: hidden; } body::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at 20% 30%, rgba(59, 130, 246, 0.08) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(168, 85, 247, 0.08) 0%, transparent 50%); pointer-events: none; z-index: -1; } @keyframes gradient-shift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } .container-404 { background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(15, 23, 36, 0.7)); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: var(--radius-lg); padding: 40px; border: 1px solid var(--border-light); box-shadow: var(--shadow-light), inset 0 1px 0 rgba(255,255,255,0.05); max-width: 600px; width: 100%; position: relative; z-index: 1; animation: fadeIn 0.8s ease-out forwards; } @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } } h1 { font-size: 72px; color: var(--accent); margin-bottom: 20px; font-weight: 800; text-shadow: 0 0 20px rgba(59, 130, 246, 0.5); animation: bounceIn 1s ease-out forwards; } @keyframes bounceIn { 0% { transform: scale(0.3); opacity: 0; } 50% { transform: scale(1.1); opacity: 1; } 70% { transform: scale(0.9); } 100% { transform: scale(1); } } p { font-size: 18px; color: var(--text-secondary); margin-bottom: 30px; line-height: 1.6; } .home-link { display: inline-block; background: linear-gradient(135deg, var(--accent) 0%, #6366f1 100%); color: white; padding: 14px 28px; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 16px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3); position: relative; overflow: hidden; } .home-link::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transition: left 0.5s ease; } .home-link:hover::before { left: 100%; } .home-link:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5); } .home-link:active { transform: translateY(0); box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3); } @media (max-width: 600px) { h1 { font-size: 56px; } p { font-size: 16px; } .container-404 { padding: 30px 20px; } } </style> </head> <body> <div class="container-404"> <h1>404</h1> <p>Oops! The page you're looking for couldn't be found.</p> <p>It might have been moved, deleted, or never existed.</p> <a href="/" class="home-link">Go to Homepage</a> </div> </body> </html>`; const headers = new Headers({ 'Content-Type': 'text/html;charset=utf-8' }); addSecurityHeaders(headers, generateNonce(), {}); ctx.waitUntil(logSecurityEvent(env.DB, ctx, clientIp, 'PAGE_NOT_FOUND', `404 hit for path: ${url.pathname}. IP: ${clientIp}.`)); return new Response(custom404Html.replace(/CSP_NONCE_PLACEHOLDER/g, generateNonce()), { status: 404, headers }); } catch (e) { console.error('Fetch handler top-level error (unhandled route):', e.message, e.stack); ctx.waitUntil(logSecurityEvent(env.DB, ctx, request.headers.get('CF-Connecting-IP') || 'unknown', 'CRITICAL_ERROR', `Unhandled fetch error in main handler: ${e.message}. Path: ${new URL(request.url).pathname}.`)); const headers = new Headers(); addSecurityHeaders(headers, null, {}); return new Response('Internal Server Error. Please try again later.', { status: 500, headers }); } }, // ============================================================================ // SCHEDULED HANDLER - Quantum Maintenance & Healing // This handler runs at intervals configured in `wrangler.toml` (e.g., cron). // It performs critical background tasks for system health and data hygiene. // ============================================================================ async scheduled(event, env, ctx) { console.log(`[Scheduled Task] Event received at ${new Date().toISOString()}`); try { await ensureTablesExist(env, ctx); console.log('Running scheduled proxy health check...'); await performHealthCheck(env, ctx); console.log('Scheduled proxy health check completed.'); console.log('Running scheduled old data cleanup...'); await cleanupOldIps(env, ctx); console.log('Scheduled old data cleanup completed.'); console.log('All scheduled tasks completed successfully.'); } catch (e) { console.error('[Scheduled Task] Execution error:', e.message, e.stack); ctx.waitUntil(logSecurityEvent(env.DB, ctx, 'system', 'SCHEDULED_TASK_ERROR', `Scheduled task failed: ${e.message}.`)); } }, };
